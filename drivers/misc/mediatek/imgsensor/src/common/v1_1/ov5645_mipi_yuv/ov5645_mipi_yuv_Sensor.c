/*
 * Copyright (C) 2017 MediaTek Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */
/*****************************************************************************
 *
 * Filename:
 * ---------
 *   ov5645mipi_Sensor.c
 *
 * Project:
 * --------
 *	 ALPS
 *
 * Description:
 * ------------
 *	 Source code of Sensor driver
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by CC/CQ. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#include <linux/videodev2.h>
#include <linux/i2c.h>
#include <linux/platform_device.h>
#include <linux/delay.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <linux/atomic.h>
#include <linux/types.h>


#include "kd_camera_typedef.h"
/* #include "kd_camera_hw.h" */
#include "kd_imgsensor.h"
#include "kd_imgsensor_define.h"
#include "kd_imgsensor_errcode.h"

#include "ov5645_mipi_yuv_Sensor.h"

#define PFX "OV5645_camera_sensor"
#define LOG_1 LOG_INF("OV5645,MIPI 2LANE\n")
#define LOG_2 LOG_INF(\
	"preview 1280*960@30fps,448Mbps/lane; capture 5M@15fps,672Mbps/lane\n")
/*******************************   Modify end    *****************************/
/* #define LOG_INF(format, args...)\
 *    xlog_printk(ANDROID_LOG_INFO   , PFX, "[%s] " format, __FUNCTION__, ##args
 */
/* #define LOGE(format, args...)\
 *    xlog_printk(ANDROID_LOG_ERROR, PFX, "[%s] " format, __FUNCTION__, ##args)
 */
/* #define LOG_INF(format, args...)\
 *    pr_debug(PFX "[%s] " format, __func__, ##args)
 */
#define LOG_INF(format, args...)\
	pr_debug(PFX "[%s] " format, __func__, ##args)
#define USE_STREAM 1

static DEFINE_SPINLOCK(imgsensor_drv_lock);

static BOOL set_param_wb(UINT16 para);
static void  set_scene_mode(UINT16 para);
static void af_Init(void);

static struct imgsensor_info_struct imgsensor_info = {
	.sensor_id = OV5645MIPI_SENSOR_ID,
	.checksum_value = 0xc3dd012b,
	.pre = {
		.pclk = 56000000,
		.linelength = 1896,
		.framelength = 984,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 1280, /*2560, =0xA00*/
		.grabwindow_height = 960, /* =0x3C0*/
		/* by different scenario */
		.mipi_data_lp2hs_settle_dc = 85,
		/* following for GetDefaultFramerateByScenario() */
		.max_framerate = 300,
	},
	.cap = {
		.pclk = 84000000,
		.linelength = 2844,
		.framelength = 1968,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 2592, /*5184,*/
		.grabwindow_height = 1944,
		.mipi_data_lp2hs_settle_dc = 85,
		.max_framerate = 150,
	},
	.normal_video = {
		.pclk = 84000000,
		.linelength = 2844,
		.framelength = 1968,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 2592, /*5184,*/
		.grabwindow_height = 1944,
		.mipi_data_lp2hs_settle_dc = 85,
		.max_framerate = 150,
	},
	.hs_video = {
		.pclk = 84000000,
		.linelength = 2844,
		.framelength = 1968,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 2592, /*5184,*/
		.grabwindow_height = 1944,
		.mipi_data_lp2hs_settle_dc = 85,
		.max_framerate = 150,
	},
	.slim_video = {
		.pclk = 84000000,
		.linelength = 2844,
		.framelength = 1968,
		.startx = 0,
		.starty = 0,
		.grabwindow_width = 2592, /*5184,*/
		.grabwindow_height = 1944,
		.mipi_data_lp2hs_settle_dc = 85,
		.max_framerate = 150,
	},
	.margin = 4,
	.min_shutter = 16,
	.max_frame_length = 0xffff,
	.awb_delay_frame = 0,
	.effect_delay_frame = 0,
	.ae_delay_frame = 2,
	.ae_shut_delay_frame = 0,
	/* shutter delay frame for AE cycle,
	 * 2 frame with ispGain_delay-shut_delay=2-0=2
	 */
	.ae_sensor_gain_delay_frame = 0,
	/* sensor gain delay frame for AE cycle,
	 * 2 frame with ispGain_delay-sensor_gain_delay=2-0=2
	 */
	.ae_ispGain_delay_frame = 2, /* isp gain delay frame for AE cycle */
	.ihdr_support = 0, /* 1, support; 0,not support */
	.ihdr_le_firstline = 0, /* 1,le first ; 0, se first */
	.sensor_mode_num = 5, /* support sensor mode num */

	.cap_delay_frame = 2,
	.pre_delay_frame = 2,
	.video_delay_frame = 2,
	.hs_video_delay_frame = 2,
	.slim_video_delay_frame = 2,

	.InitDelay = 0, /* init setting delay frame */
	.EffectDelay = 0, /* EffectDelay setting delay frame */
	.AwbDelay = 0, /* AwbDelay setting delay frame */
	/*touch af back to continue af need frame num ,its value awlas 50 */
	.AFSwitchDelayFrame = 50,

	.isp_driving_current = ISP_DRIVING_6MA,
	.sensor_interface_type = SENSOR_INTERFACE_TYPE_MIPI,
	/* 0,MIPI_OPHY_NCSI2;  1,MIPI_OPHY_CSI2 */
	.mipi_sensor_type = MIPI_OPHY_NCSI2,
	/* 0,MIPI_SETTLEDELAY_AUTO; 1,MIPI_SETTLEDELAY_MANUAL */
	.mipi_settle_delay_mode = MIPI_SETTLEDELAY_MANUAL,
	.sensor_output_dataformat = SENSOR_OUTPUT_FORMAT_YUYV, /* YUV422 */
	.mclk = 24,
	.mipi_lane_num = SENSOR_MIPI_2_LANE,
	.i2c_addr_table = {0x78, 0xff},
	.i2c_speed = 300, /* i2c read/write speed*/

	.minframerate = 0,
	.maxframerate = 0,
	.flash_bv_threshold = 0x25,
};


static struct imgsensor_struct imgsensor = {
	.mirror = IMAGE_V_MIRROR,	/* mirrorflip information */
	.sensor_mode = IMGSENSOR_MODE_INIT,
	/* IMGSENSOR_MODE enum value,record current sensor mode */
	/* such as: INIT, Preview, Capture, Video,High Speed Video, Slim Video*/
	.shutter = 0x100,	/* current shutter */
	.gain = 0x3F,		/* current gain */
	.dummy_pixel = 0,	/* current dummypixel */
	.dummy_line = 0,	/* current dummyline */
	.current_fps = 0,  /* full size current fps : 24fps for PIP,
			    * 30fps for Normal or ZSD
			    */
	.autoflicker_en = KAL_FALSE,
	/* auto flicker enable: KAL_FALSE for disable auto flicker,
	 * KAL_TRUE for enable auto flicker
	 */
	.test_pattern = KAL_FALSE,
	/* test pattern mode or not. KAL_FALSE for in test pattern mode,
	 * KAL_TRUE for normal output
	 */
	 /* current scenario id */
	.current_scenario_id = MSDK_SCENARIO_ID_CAMERA_PREVIEW,
	.iso_speed = AE_ISO_100,
	.FNumber = 28,
	.awb_mode = AWB_MODE_AUTO,
	.scene_mode = SCENE_MODE_OFF,
	.awbaelock = KAL_FALSE,
	.ihdr_en = KAL_FALSE, /* sensor need support LE, SE with HDR feature */
	.i2c_write_id = 0x78,
	.af_coordinate_y = 0x00, /* touch af window */
	.af_coordinate_y = 0x00,
	.caf_flag = KAL_FALSE,
};
/* =====================For touch ae========================== */
#define AE_WIN_MUN_H (4)
#define AE_WIN_MUN_W (4)
static UINT32 ae_win_w[AE_WIN_MUN_W] = {FALSE};
static UINT32 ae_win_h[AE_WIN_MUN_H] = {FALSE};
static BOOL ae_pline_table[AE_WIN_MUN_W][AE_WIN_MUN_H] = {
	{FALSE}, {FALSE}, {FALSE}, {FALSE} };

/* ==================For iBurstWriteReg AF regs begin====================== */
static kal_uint8 addr_data_pair1[254] = {
	0x80,
	0x00,
	0x02,
	0x15,
	0x5c,
	0x02,
	0x12,
	0x01,
	0xc2,
	0x01,
	0x22,
	0x00,
	0x00,
	0x02,
	0x15,
	0x18,
	0x78,
	0xc3,
	0xe6,
	0x18,
	0xf6,
	0xe5,
	0x30,
	0xc3,
	0x13,
	0xfc,
	0xe5,
	0x31,
	0x13,
	0xfd,
	0xe5,
	0x2e,
	0xc3,
	0x13,
	0xfe,
	0xe5,
	0x2f,
	0x13,
	0x2d,
	0x78,
	0x9b,
	0xf6,
	0xee,
	0x3c,
	0x18,
	0xf6,
	0x78,
	0xc3,
	0xa6,
	0x4f,
	0xe5,
	0x1e,
	0x70,
	0x6b,
	0xe6,
	0x12,
	0x0f,
	0x25,
	0xff,
	0x33,
	0x95,
	0xe0,
	0xfe,
	0x74,
	0x9d,
	0x2f,
	0xf5,
	0x82,
	0x74,
	0x0e,
	0x3e,
	0xf5,
	0x83,
	0xe4,
	0x93,
	0x78,
	0xc1,
	0xf6,
	0x75,
	0x4e,
	0x02,
	0x12,
	0x0f,
	0x31,
	0x78,
	0x56,
	0x12,
	0x0f,
	0x2c,
	0x78,
	0x96,
	0x12,
	0x0f,
	0x2c,
	0x12,
	0x0f,
	0x91,
	0x78,
	0xc3,
	0xe6,
	0x78,
	0x9e,
	0xf6,
	0x78,
	0xc3,
	0xe6,
	0x78,
	0xbe,
	0xf6,
	0x78,
	0xc3,
	0xe6,
	0x78,
	0xbf,
	0xf6,
	0x08,
	0x76,
	0x02,
	0x78,
	0xc5,
	0x76,
	0x01,
	0x08,
	0x76,
	0x01,
	0x08,
	0x76,
	0x01,
	0xe6,
	0x78,
	0xc9,
	0xf6,
	0xe6,
	0x78,
	0xcb,
	0xf6,
	0x78,
	0xc9,
	0xe6,
	0x78,
	0xcc,
	0xf6,
	0xe4,
	0x08,
	0xf6,
	0x08,
	0xf6,
	0x08,
	0x76,
	0x40,
	0x78,
	0xc3,
	0xe6,
	0x78,
	0xd0,
	0xf6,
	0xe4,
	0x08,
	0xf6,
	0xc2,
	0x38,
	0xe5,
	0x1e,
	0x64,
	0x06,
	0x70,
	0x2e,
	0xd3,
	0x78,
	0xc0,
	0xe6,
	0x64,
	0x80,
	0x94,
	0x80,
	0x40,
	0x02,
	0x16,
	0x22,
	0xa2,
	0x38,
	0xe4,
	0x33,
	0xf5,
	0x41,
	0x90,
	0x30,
	0x28,
	0xf0,
	0xe4,
	0xf5,
	0x1e,
	0xc2,
	0x01,
	0x75,
	0x1d,
	0x10,
	0xd2,
	0x36,
	0x78,
	0x52,
	0xa6,
	0x2e,
	0x08,
	0xa6,
	0x2f,
	0x08,
	0xa6,
	0x30,
	0x08,
	0xa6,
	0x31,
	0x22,
	0x79,
	0xc3,
	0xe7,
	0x78,
	0xc1,
	0x26,
	0x78,
	0xc4,
	0xf6,
	0xc3,
	0x78,
	0xce,
	0xe6,
	0x64,
	0x80,
	0xf8,
	0x09,
	0xe7,
	0x64,
	0x80,
	0x98,
	0x50,
	0x06,
	0x78,
	0xce,
	0xe6,
	0x78,
	0xc4,
	0xf6,
	0xd3,
	0x78,
	0xcf,
	0xe6,
	0x64,
	0x80,
	0xf8,
	0x79,
	0xc4,
	0xe7,
	0x64,
	0x80,
};
static kal_uint8 addr_data_pair2[255] = {
	0x80,
	0xfc,
	0x98,
	0x40,
	0x06,
	0x78,
	0xcf,
	0xe6,
	0x78,
	0xc4,
	0xf6,
	0x78,
	0xc4,
	0xe6,
	0xf5,
	0x4f,
	0x12,
	0x12,
	0xaf,
	0x78,
	0xc1,
	0xe6,
	0xff,
	0x33,
	0x95,
	0xe0,
	0xfe,
	0x12,
	0x15,
	0x2e,
	0x8f,
	0x0a,
	0xd3,
	0xe5,
	0x0a,
	0x64,
	0x80,
	0x94,
	0x86,
	0x40,
	0x05,
	0x75,
	0x1e,
	0x01,
	0x80,
	0x1f,
	0xd3,
	0xe5,
	0x0a,
	0x64,
	0x80,
	0x94,
	0x83,
	0x40,
	0x05,
	0x75,
	0x1e,
	0x02,
	0x80,
	0x11,
	0xd3,
	0xe5,
	0x0a,
	0x64,
	0x80,
	0x94,
	0x81,
	0x40,
	0x05,
	0x75,
	0x1e,
	0x03,
	0x80,
	0x03,
	0x75,
	0x1e,
	0x04,
	0xd3,
	0x78,
	0xc0,
	0xe6,
	0x64,
	0x80,
	0x94,
	0x80,
	0x40,
	0x02,
	0x16,
	0x22,
	0x78,
	0xc6,
	0xe6,
	0x18,
	0xf6,
	0x08,
	0x06,
	0x78,
	0xc2,
	0xe6,
	0xff,
	0x12,
	0x0f,
	0x99,
	0x12,
	0x0f,
	0x2f,
	0x78,
	0xc5,
	0xe6,
	0x25,
	0xe0,
	0x24,
	0x56,
	0xf8,
	0xa6,
	0x06,
	0x08,
	0xa6,
	0x07,
	0x79,
	0xc5,
	0xe7,
	0x78,
	0xc7,
	0x66,
	0x70,
	0x05,
	0xe6,
	0x78,
	0xc9,
	0xf6,
	0x22,
	0x78,
	0xc5,
	0xe6,
	0x78,
	0x99,
	0x12,
	0x0e,
	0xfa,
	0x40,
	0x0d,
	0x78,
	0xc5,
	0xe6,
	0x12,
	0x0e,
	0xdf,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0x12,
	0x0f,
	0x91,
	0x78,
	0xc5,
	0xe6,
	0x25,
	0xe0,
	0x24,
	0x57,
	0xf9,
	0xc3,
	0xe7,
	0x78,
	0x97,
	0x96,
	0x19,
	0xe7,
	0x18,
	0x96,
	0x50,
	0x11,
	0x78,
	0xc5,
	0xe6,
	0x12,
	0x0e,
	0xdf,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0x78,
	0x96,
	0xa6,
	0x06,
	0x08,
	0xa6,
	0x07,
	0x78,
	0xc5,
	0xe6,
	0x25,
	0xe0,
	0x24,
	0x57,
	0xf9,
	0x78,
	0xc9,
	0xe6,
	0x12,
	0x0e,
	0xdf,
	0xfe,
	0x08,
	0xe6,
	0xc3,
	0x97,
	0xee,
	0x19,
	0x97,
	0x50,
	0x06,
	0x78,
	0xc5,
	0xe6,
	0x78,
	0xc9,
	0xf6,
	0x78,
	0xc5,
	0xe6,
	0x24,
	0x9e,
	0x78,
	0xbe,
	0x12,
	0x0f,
	0x09,
	0x40,
	0x07,
	0x12,
	0x0f,
	0x99,
	0xe6,
	0x78,
	0xbe,
	0xf6,
	0x78,
	0xc5,
	0xe6,
	0x24,
	0x9e,
	0x78,
	0xbf,
	0x12,
	0x0e,
	0xe8,
	0x50,
	0x07,
	0x12,
	0x0f,
	0x99,
};
static kal_uint8 addr_data_pair3[255] = {
	0x81,
	0xf9,
	0xe6,
	0x78,
	0xbf,
	0xf6,
	0x78,
	0xc5,
	0xe6,
	0x78,
	0xc8,
	0xf6,
	0x12,
	0x10,
	0x7f,
	0x12,
	0x0c,
	0x86,
	0x12,
	0x14,
	0xdd,
	0x78,
	0xcd,
	0xa6,
	0x07,
	0xe6,
	0x24,
	0x02,
	0x70,
	0x03,
	0x02,
	0x02,
	0x9e,
	0x14,
	0x70,
	0x03,
	0x02,
	0x02,
	0x9e,
	0x24,
	0xfe,
	0x60,
	0x03,
	0x02,
	0x03,
	0xb1,
	0xd2,
	0x38,
	0x12,
	0x0f,
	0x16,
	0x40,
	0x16,
	0x78,
	0xc9,
	0xe6,
	0x24,
	0x9d,
	0x12,
	0x0e,
	0xe6,
	0x50,
	0x20,
	0x78,
	0xc9,
	0xe6,
	0x24,
	0x9d,
	0xf8,
	0xe6,
	0x78,
	0xce,
	0xf6,
	0x80,
	0x14,
	0x78,
	0xc9,
	0xe6,
	0x24,
	0x9d,
	0x12,
	0x0f,
	0x07,
	0x40,
	0x0a,
	0x78,
	0xc9,
	0xe6,
	0x24,
	0x9d,
	0xf8,
	0xe6,
	0x78,
	0xcf,
	0xf6,
	0x78,
	0xca,
	0x12,
	0x0f,
	0x52,
	0x79,
	0xc2,
	0xe7,
	0x78,
	0xc3,
	0x66,
	0x60,
	0x03,
	0x02,
	0x04,
	0x9f,
	0x78,
	0xd1,
	0x06,
	0xe5,
	0x1e,
	0xb4,
	0x01,
	0x07,
	0x12,
	0x0f,
	0x1f,
	0xf6,
	0x09,
	0x80,
	0x1e,
	0xe5,
	0x1e,
	0xb4,
	0x02,
	0x08,
	0x12,
	0x0f,
	0x1f,
	0xf6,
	0x79,
	0xc3,
	0x80,
	0x11,
	0xe5,
	0x1e,
	0xb4,
	0x03,
	0x14,
	0x78,
	0xc1,
	0xe6,
	0xf4,
	0x04,
	0xff,
	0xa2,
	0xe7,
	0x13,
	0xf6,
	0x79,
	0xc3,
	0xe7,
	0x26,
	0x78,
	0xc4,
	0xf6,
	0x02,
	0x04,
	0x8a,
	0x02,
	0x04,
	0x1c,
	0xd2,
	0x38,
	0x78,
	0xd1,
	0x06,
	0xc3,
	0x12,
	0x0f,
	0x17,
	0x50,
	0x25,
	0x79,
	0xc9,
	0xe7,
	0x78,
	0xc5,
	0x66,
	0x78,
	0xc9,
	0x60,
	0x05,
	0xe6,
	0x04,
	0xff,
	0x80,
	0x02,
	0xe6,
	0xff,
	0x8f,
	0x0a,
	0x74,
	0x9e,
	0x2f,
	0x12,
	0x0e,
	0xe6,
	0x50,
	0x2d,
	0x74,
	0x9e,
	0x2f,
	0xf8,
	0xe6,
	0x78,
	0xce,
	0xf6,
	0x80,
	0x23,
	0x79,
	0xc9,
	0xe7,
	0x78,
	0xc5,
	0x66,
	0x78,
	0xc9,
	0x60,
	0x05,
	0xe6,
	0x04,
	0xff,
	0x80,
	0x02,
	0xe6,
	0xff,
	0x8f,
	0x0a,
	0x74,
	0x9e,
	0x2f,
	0x12,
	0x0f,
	0x07,
	0x40,
	0x08,
	0x74,
	0x9e,
	0x2f,
	0xf8,
	0xe6,
	0x78,
	0xcf,
	0xf6,
	0x12,
	0x0f,
	0x50,
	0x78,
	0xc1,
};
static kal_uint8 addr_data_pair4[255] = {
	0x82,
	0xf6,
	0xe6,
	0xff,
	0x33,
	0x95,
	0xe0,
	0xfe,
	0xef,
	0x78,
	0x02,
	0xc3,
	0x33,
	0xce,
	0x33,
	0xce,
	0xd8,
	0xf9,
	0xff,
	0x12,
	0x15,
	0x2e,
	0x78,
	0xce,
	0xe6,
	0xfd,
	0x33,
	0x95,
	0xe0,
	0xfc,
	0x08,
	0xe6,
	0xfb,
	0x33,
	0x95,
	0xe0,
	0xfa,
	0xc3,
	0xeb,
	0x9d,
	0xfd,
	0xea,
	0x9c,
	0xfc,
	0xd3,
	0xed,
	0x9f,
	0xee,
	0x64,
	0x80,
	0xf8,
	0xec,
	0x64,
	0x80,
	0x98,
	0x40,
	0x02,
	0x80,
	0x01,
	0xd3,
	0x92,
	0x3a,
	0xe5,
	0x1e,
	0x64,
	0x01,
	0x70,
	0x21,
	0x12,
	0x0f,
	0x72,
	0x30,
	0x3a,
	0x05,
	0xe6,
	0xa2,
	0xe7,
	0x13,
	0xf6,
	0x12,
	0x0f,
	0x16,
	0x40,
	0x06,
	0x78,
	0xce,
	0xe6,
	0xff,
	0x80,
	0x04,
	0x78,
	0xcf,
	0xe6,
	0xff,
	0x78,
	0xc4,
	0xa6,
	0x07,
	0x02,
	0x04,
	0x8a,
	0xe5,
	0x1e,
	0x64,
	0x02,
	0x70,
	0x21,
	0x12,
	0x0f,
	0x72,
	0x30,
	0x3a,
	0x05,
	0xe6,
	0xa2,
	0xe7,
	0x13,
	0xf6,
	0x12,
	0x0f,
	0x16,
	0x40,
	0x06,
	0x78,
	0xce,
	0xe6,
	0xff,
	0x80,
	0x04,
	0x78,
	0xcf,
	0xe6,
	0xff,
	0x78,
	0xc4,
	0xa6,
	0x07,
	0x02,
	0x04,
	0x8a,
	0xe5,
	0x1e,
	0x64,
	0x03,
	0x70,
	0x21,
	0x12,
	0x0f,
	0x72,
	0x30,
	0x3a,
	0x05,
	0xe6,
	0xa2,
	0xe7,
	0x13,
	0xf6,
	0x12,
	0x0f,
	0x16,
	0x40,
	0x06,
	0x78,
	0xce,
	0xe6,
	0xff,
	0x80,
	0x04,
	0x78,
	0xcf,
	0xe6,
	0xff,
	0x78,
	0xc4,
	0xa6,
	0x07,
	0x02,
	0x04,
	0x8a,
	0x78,
	0xc0,
	0x76,
	0x01,
	0x12,
	0x0f,
	0xa0,
	0x02,
	0x04,
	0x9c,
	0x79,
	0xc2,
	0xe7,
	0x78,
	0xc3,
	0x66,
	0x60,
	0x03,
	0x02,
	0x04,
	0x9f,
	0x78,
	0xd1,
	0x06,
	0xc3,
	0x12,
	0x0f,
	0x17,
	0x50,
	0x16,
	0x78,
	0xc9,
	0xe6,
	0x24,
	0x9f,
	0x12,
	0x0e,
	0xe6,
	0x50,
	0x20,
	0x78,
	0xc9,
	0xe6,
	0x24,
	0x9f,
	0xf8,
	0xe6,
	0x78,
	0xce,
	0xf6,
	0x80,
	0x14,
	0x78,
	0xc9,
	0xe6,
	0x24,
	0x9f,
	0x12,
	0x0f,
	0x07,
	0x40,
	0x0a,
	0x78,
	0xc9,
	0xe6,
	0x24,
	0x9f,
	0xf8,
	0xe6,
	0x78,
	0xcf,
	0xf6,
	0x12,
	0x0f,
	0x50,
	0x20,
};
static kal_uint8 addr_data_pair5[255] = {
	0x83,
	0xf3,
	0x38,
	0x2e,
	0xc3,
	0x08,
	0xe6,
	0x64,
	0x80,
	0x94,
	0x82,
	0x50,
	0x1b,
	0x12,
	0x0f,
	0x72,
	0xe6,
	0x64,
	0x80,
	0x94,
	0x80,
	0x40,
	0x06,
	0x78,
	0xce,
	0xe6,
	0xff,
	0x80,
	0x04,
	0x78,
	0xcf,
	0xe6,
	0xff,
	0x78,
	0xc4,
	0xa6,
	0x07,
	0x02,
	0x04,
	0x8a,
	0x12,
	0x0f,
	0xa0,
	0x78,
	0xc0,
	0x76,
	0x01,
	0x02,
	0x04,
	0x9c,
	0xe5,
	0x1e,
	0x64,
	0x01,
	0x70,
	0x1d,
	0x78,
	0xc1,
	0xe6,
	0xf4,
	0x04,
	0x12,
	0x0f,
	0x25,
	0x12,
	0x0f,
	0x81,
	0x40,
	0x06,
	0x78,
	0xce,
	0xe6,
	0xff,
	0x80,
	0x04,
	0x78,
	0xcf,
	0xe6,
	0xff,
	0x78,
	0xc4,
	0xa6,
	0x07,
	0x80,
	0x44,
	0xe5,
	0x1e,
	0x64,
	0x02,
	0x70,
	0x1d,
	0x78,
	0xc1,
	0xe6,
	0xf4,
	0x04,
	0x12,
	0x0f,
	0x25,
	0x12,
	0x0f,
	0x81,
	0x40,
	0x06,
	0x78,
	0xce,
	0xe6,
	0xff,
	0x80,
	0x04,
	0x78,
	0xcf,
	0xe6,
	0xff,
	0x78,
	0xc4,
	0xa6,
	0x07,
	0x80,
	0x21,
	0xe5,
	0x1e,
	0x64,
	0x03,
	0x70,
	0x26,
	0x78,
	0xc1,
	0xe6,
	0xf4,
	0x04,
	0xa2,
	0xe7,
	0x13,
	0x12,
	0x0f,
	0x81,
	0x40,
	0x06,
	0x78,
	0xce,
	0xe6,
	0xff,
	0x80,
	0x04,
	0x78,
	0xcf,
	0xe6,
	0xff,
	0x78,
	0xc4,
	0xa6,
	0x07,
	0x78,
	0xc6,
	0xe6,
	0x08,
	0xf6,
	0x78,
	0xc0,
	0x76,
	0x01,
	0x80,
	0x0a,
	0x12,
	0x0f,
	0xa0,
	0x78,
	0xc0,
	0x76,
	0x01,
	0x75,
	0x1e,
	0x06,
	0x78,
	0xc4,
	0xe6,
	0xf5,
	0x4f,
	0x12,
	0x12,
	0xaf,
	0x22,
	0x30,
	0x01,
	0x03,
	0x02,
	0x08,
	0x5f,
	0x30,
	0x02,
	0x03,
	0x02,
	0x08,
	0x5f,
	0xe5,
	0x1e,
	0x60,
	0x03,
	0x02,
	0x05,
	0x3b,
	0x75,
	0x1d,
	0x20,
	0xd2,
	0x36,
	0xd3,
	0x78,
	0x53,
	0xe6,
	0x94,
	0x00,
	0x18,
	0xe6,
	0x94,
	0x00,
	0x40,
	0x07,
	0xe6,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0x80,
	0x0e,
	0x90,
	0x0e,
	0x8d,
	0xe4,
	0x93,
	0x25,
	0xe0,
	0x25,
	0xe0,
	0x24,
	0x2a,
	0x12,
	0x11,
	0x8e,
	0x78,
	0x52,
	0xa6,
	0x06,
	0x08,
	0xa6,
	0x07,
	0xd3,
	0x78,
	0x55,
	0xe6,
	0x94,
	0x00,
	0x18,
	0xe6,

};
static kal_uint8 addr_data_pair6[255] = {
	0x84,
	0xf0,
	0x94,
	0x00,
	0x40,
	0x07,
	0xe6,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0x80,
	0x08,
	0x90,
	0x0e,
	0x8d,
	0xe4,
	0x93,
	0x12,
	0x11,
	0x88,
	0x78,
	0x54,
	0xa6,
	0x06,
	0x08,
	0xa6,
	0x07,
	0x12,
	0x11,
	0xd8,
	0x12,
	0x11,
	0xa9,
	0x78,
	0x5a,
	0x12,
	0x11,
	0x82,
	0x78,
	0x5c,
	0xa6,
	0x06,
	0x08,
	0xa6,
	0x07,
	0x12,
	0x11,
	0xd8,
	0x78,
	0xad,
	0xa6,
	0x33,
	0x08,
	0xa6,
	0x33,
	0x08,
	0xa6,
	0x35,
	0x78,
	0xb3,
	0xa6,
	0x33,
	0x08,
	0xa6,
	0x33,
	0x08,
	0xa6,
	0x35,
	0x75,
	0x1e,
	0x01,
	0x78,
	0xaa,
	0x76,
	0x01,
	0x22,
	0xe5,
	0x1e,
	0xb4,
	0x05,
	0x10,
	0xd2,
	0x01,
	0xc2,
	0x02,
	0xe4,
	0xf5,
	0x1e,
	0xf5,
	0x1d,
	0xd2,
	0x36,
	0xd2,
	0x34,
	0xd2,
	0x37,
	0x22,
	0x12,
	0x11,
	0xc7,
	0x24,
	0xb3,
	0x12,
	0x11,
	0xc4,
	0x24,
	0xb4,
	0x12,
	0x11,
	0xc4,
	0x24,
	0xb5,
	0xf8,
	0xa6,
	0x35,
	0x12,
	0x11,
	0xa9,
	0x12,
	0x11,
	0xbc,
	0x24,
	0x5a,
	0xf8,
	0x12,
	0x11,
	0x82,
	0x12,
	0x11,
	0xbc,
	0x24,
	0x5c,
	0xf8,
	0xa6,
	0x06,
	0x08,
	0xa6,
	0x07,
	0x12,
	0x11,
	0xbc,
	0x24,
	0x5e,
	0xf8,
	0xa6,
	0x2a,
	0x08,
	0xa6,
	0x2b,
	0x12,
	0x11,
	0xbc,
	0x24,
	0x60,
	0xf8,
	0xa6,
	0x2c,
	0x08,
	0xa6,
	0x2d,
	0x90,
	0x0e,
	0x99,
	0xe4,
	0x93,
	0x24,
	0xff,
	0xff,
	0xe4,
	0x34,
	0xff,
	0xfe,
	0x78,
	0xaa,
	0xe6,
	0x24,
	0x01,
	0xfd,
	0xe4,
	0x33,
	0xfc,
	0xd3,
	0xed,
	0x9f,
	0xee,
	0x64,
	0x80,
	0xf8,
	0xec,
	0x64,
	0x80,
	0x98,
	0x40,
	0x04,
	0x7f,
	0x00,
	0x80,
	0x05,
	0x78,
	0xaa,
	0xe6,
	0x04,
	0xff,
	0x78,
	0xaa,
	0xa6,
	0x07,
	0xe5,
	0x1e,
	0xb4,
	0x01,
	0x07,
	0xe6,
	0x70,
	0x04,
	0x75,
	0x1e,
	0x02,
	0x22,
	0xe4,
	0x78,
	0xab,
	0xf6,
	0x08,
	0xf6,
	0xf5,
	0x0b,
	0x12,
	0x11,
	0xcf,
	0xf5,
	0x14,
	0x08,
	0xe6,
	0xf5,
	0x15,
	0x12,
	0x11,
	0xcf,
	0xf5,
	0x16,
	0x08,
	0xe6,
	0xf5,
	0x17,
	0x12,
	0x11,
	0xcf,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0x12,
	0x11,
};
static kal_uint8 addr_data_pair7[255] = {
	0x85,
	0xed,
	0xf0,
	0x75,
	0x0a,
	0x01,
	0x90,
	0x0e,
	0x99,
	0xe4,
	0x93,
	0xfb,
	0xe5,
	0x0a,
	0xc3,
	0x9b,
	0x50,
	0x67,
	0x12,
	0x11,
	0x73,
	0xf8,
	0xe6,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0xe4,
	0xfc,
	0xfd,
	0xe5,
	0x0f,
	0x2f,
	0xf5,
	0x0f,
	0xe5,
	0x0e,
	0x3e,
	0xf5,
	0x0e,
	0xed,
	0x35,
	0x0d,
	0xf5,
	0x0d,
	0xec,
	0x35,
	0x0c,
	0xf5,
	0x0c,
	0xe5,
	0x0a,
	0x75,
	0xf0,
	0x08,
	0xa4,
	0x24,
	0x5b,
	0x12,
	0x11,
	0x7b,
	0xf9,
	0xc3,
	0xe5,
	0x15,
	0x97,
	0xe5,
	0x14,
	0x19,
	0x97,
	0x50,
	0x0b,
	0x12,
	0x11,
	0x73,
	0xf8,
	0xe6,
	0xf5,
	0x14,
	0x08,
	0xe6,
	0xf5,
	0x15,
	0xe5,
	0x0a,
	0x75,
	0xf0,
	0x08,
	0xa4,
	0x24,
	0x5b,
	0x12,
	0x11,
	0x7b,
	0xf9,
	0xd3,
	0xe5,
	0x17,
	0x97,
	0xe5,
	0x16,
	0x19,
	0x97,
	0x40,
	0x0b,
	0x12,
	0x11,
	0x73,
	0xf8,
	0xe6,
	0xf5,
	0x16,
	0x08,
	0xe6,
	0xf5,
	0x17,
	0x05,
	0x0a,
	0x02,
	0x05,
	0xf1,
	0xe4,
	0xfa,
	0xf9,
	0xf8,
	0xaf,
	0x0f,
	0xae,
	0x0e,
	0xad,
	0x0d,
	0xac,
	0x0c,
	0x12,
	0x0b,
	0x7b,
	0x8e,
	0x18,
	0x8f,
	0x19,
	0xc3,
	0xe5,
	0x15,
	0x95,
	0x17,
	0xff,
	0xe5,
	0x14,
	0x95,
	0x16,
	0xfe,
	0xe5,
	0x0b,
	0x25,
	0xe0,
	0x24,
	0x53,
	0xf9,
	0xd3,
	0xe5,
	0x15,
	0x97,
	0xe5,
	0x14,
	0x19,
	0x97,
	0xe5,
	0x0b,
	0x40,
	0x11,
	0x25,
	0xe0,
	0x24,
	0x53,
	0xf8,
	0xc3,
	0xe5,
	0x15,
	0x96,
	0xfd,
	0xe5,
	0x14,
	0x18,
	0x96,
	0xfc,
	0x80,
	0x0f,
	0x25,
	0xe0,
	0x24,
	0x53,
	0xf8,
	0xc3,
	0xe6,
	0x95,
	0x15,
	0xfd,
	0x18,
	0xe6,
	0x95,
	0x14,
	0xfc,
	0x8c,
	0x1a,
	0x8d,
	0x1b,
	0x12,
	0x11,
	0xf0,
	0x12,
	0x11,
	0x6a,
	0x90,
	0x0e,
	0x8e,
	0x12,
	0x11,
	0x95,
	0xe4,
	0x85,
	0x15,
	0x13,
	0x85,
	0x14,
	0x12,
	0xf5,
	0x11,
	0xf5,
	0x10,
	0xaf,
	0x13,
	0xae,
	0x12,
	0x7b,
	0x04,
	0x12,
	0x11,
	0x58,
	0xc3,
	0x12,
	0x0c,
	0x0d,
	0x50,
	0x11,
	0xaf,
	0x0b,
	0x74,
	0x01,
	0xa8,
	0x07,
	0x08,
	0x80,
	0x02,
	0xc3,
	0x33,
};
static kal_uint8 addr_data_pair8[255] = {
	0x86,
	0xea,
	0xd8,
	0xfc,
	0x78,
	0xab,
	0x26,
	0xf6,
	0xe4,
	0x85,
	0x1b,
	0x0f,
	0x85,
	0x1a,
	0x0e,
	0xf5,
	0x0d,
	0xf5,
	0x0c,
	0x12,
	0x11,
	0x6a,
	0x90,
	0x0e,
	0x92,
	0x12,
	0x11,
	0x95,
	0xe5,
	0x0b,
	0x25,
	0xe0,
	0x24,
	0x53,
	0xf9,
	0xd3,
	0xe5,
	0x19,
	0x97,
	0xe5,
	0x18,
	0x19,
	0x97,
	0x40,
	0x0e,
	0xe5,
	0x0b,
	0x25,
	0xe0,
	0x24,
	0x52,
	0xf8,
	0xe6,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0x80,
	0x04,
	0xae,
	0x18,
	0xaf,
	0x19,
	0xe4,
	0x8f,
	0x13,
	0x8e,
	0x12,
	0xf5,
	0x11,
	0xf5,
	0x10,
	0x7b,
	0x10,
	0x12,
	0x11,
	0x58,
	0xd3,
	0x12,
	0x0c,
	0x0d,
	0x40,
	0x11,
	0xaf,
	0x0b,
	0x74,
	0x01,
	0xa8,
	0x07,
	0x08,
	0x80,
	0x02,
	0xc3,
	0x33,
	0xd8,
	0xfc,
	0x78,
	0xac,
	0x26,
	0xf6,
	0x05,
	0x0b,
	0xe5,
	0x0b,
	0x64,
	0x04,
	0x60,
	0x03,
	0x02,
	0x05,
	0xd2,
	0xe4,
	0xf5,
	0x0b,
	0x12,
	0x11,
	0xfa,
	0xfb,
	0x12,
	0x11,
	0xfa,
	0xfa,
	0x12,
	0x11,
	0xfa,
	0x75,
	0x18,
	0x00,
	0xf5,
	0x19,
	0x75,
	0x0a,
	0x01,
	0x90,
	0x0e,
	0x99,
	0xe4,
	0x93,
	0xff,
	0xe5,
	0x0a,
	0xc3,
	0x9f,
	0x50,
	0x2a,
	0x12,
	0x11,
	0x4b,
	0x25,
	0x19,
	0xf5,
	0x19,
	0xe4,
	0x35,
	0x18,
	0xf5,
	0x18,
	0x12,
	0x11,
	0x4b,
	0xfe,
	0xeb,
	0xc3,
	0x9e,
	0x50,
	0x04,
	0x12,
	0x11,
	0x4b,
	0xfb,
	0x12,
	0x11,
	0x4b,
	0xfe,
	0xea,
	0xd3,
	0x9e,
	0x40,
	0x04,
	0x12,
	0x11,
	0x4b,
	0xfa,
	0x05,
	0x0a,
	0x80,
	0xca,
	0xef,
	0xfd,
	0x7c,
	0x00,
	0xae,
	0x18,
	0xaf,
	0x19,
	0x12,
	0x0a,
	0x9b,
	0xc3,
	0xeb,
	0x9a,
	0xfe,
	0x74,
	0xad,
	0x25,
	0x0b,
	0xf8,
	0xe6,
	0xfd,
	0xef,
	0xd3,
	0x9d,
	0x74,
	0xad,
	0x40,
	0x0b,
	0x25,
	0x0b,
	0xf8,
	0xe6,
	0xfd,
	0xc3,
	0xef,
	0x9d,
	0xff,
	0x80,
	0x07,
	0x25,
	0x0b,
	0xf8,
	0xc3,
	0xe6,
	0x9f,
	0xff,
	0x8f,
	0x1c,
	0x90,
	0x0e,
	0x96,
	0xe4,
	0x93,
	0xff,
	0xee,
	0xc3,
	0x9f,
	0x50,
	0x0d,
	0x12,
	0x11,
	0xe5,
	0x80,
	0x02,
	0xc3,
	0x33,
	0xd8,
};
static kal_uint8 addr_data_pair9[255] = {
	0x87,
	0xe7,
	0xfc,
	0x78,
	0xab,
	0x26,
	0xf6,
	0x90,
	0x0e,
	0x97,
	0xe4,
	0x93,
	0xff,
	0xe5,
	0x1c,
	0xd3,
	0x9f,
	0x40,
	0x0d,
	0x12,
	0x11,
	0xe5,
	0x80,
	0x02,
	0xc3,
	0x33,
	0xd8,
	0xfc,
	0x78,
	0xac,
	0x26,
	0xf6,
	0x74,
	0xb0,
	0x25,
	0x0b,
	0xf8,
	0xa6,
	0x1c,
	0x05,
	0x0b,
	0xe5,
	0x0b,
	0x64,
	0x03,
	0x60,
	0x03,
	0x02,
	0x07,
	0x5a,
	0x78,
	0xb1,
	0xe6,
	0xff,
	0x18,
	0xe6,
	0x2f,
	0xff,
	0xe4,
	0x33,
	0xfe,
	0x78,
	0xb2,
	0xe6,
	0x7c,
	0x00,
	0x2f,
	0xf5,
	0x1b,
	0xec,
	0x3e,
	0xf5,
	0x1a,
	0x90,
	0x0e,
	0x98,
	0xe4,
	0x93,
	0xff,
	0xd3,
	0xe5,
	0x1b,
	0x9f,
	0xe5,
	0x1a,
	0x94,
	0x00,
	0x40,
	0x06,
	0x78,
	0xac,
	0x74,
	0x80,
	0x26,
	0xf6,
	0x78,
	0xac,
	0xe6,
	0x79,
	0xab,
	0x57,
	0xf6,
	0xe5,
	0x1e,
	0xb4,
	0x02,
	0x0f,
	0x18,
	0xe6,
	0xb4,
	0x7f,
	0x0a,
	0x08,
	0xe6,
	0xd3,
	0x94,
	0x00,
	0x40,
	0x03,
	0x75,
	0x1e,
	0x05,
	0x22,
	0x90,
	0x0e,
	0x89,
	0x12,
	0x0c,
	0x44,
	0x8f,
	0x4d,
	0x8e,
	0x4c,
	0x8d,
	0x4b,
	0x8c,
	0x4a,
	0x90,
	0x38,
	0x04,
	0x12,
	0x14,
	0xa8,
	0xfb,
	0xaa,
	0x06,
	0x90,
	0x38,
	0x00,
	0x12,
	0x14,
	0xa8,
	0xff,
	0xc3,
	0xeb,
	0x9f,
	0xfb,
	0xea,
	0x9e,
	0xfa,
	0x90,
	0x38,
	0x10,
	0xe0,
	0xa3,
	0xe0,
	0x75,
	0xf0,
	0x02,
	0xa4,
	0xff,
	0xc3,
	0xeb,
	0x9f,
	0xfb,
	0xea,
	0x95,
	0xf0,
	0xfa,
	0x90,
	0x38,
	0x06,
	0xe0,
	0xfe,
	0xa3,
	0xe0,
	0xfd,
	0xee,
	0xf5,
	0x0c,
	0xed,
	0xf5,
	0x0d,
	0x90,
	0x38,
	0x02,
	0x12,
	0x14,
	0xa8,
	0xff,
	0x12,
	0x14,
	0x91,
	0x90,
	0x38,
	0x12,
	0xe0,
	0xa3,
	0xe0,
	0x75,
	0xf0,
	0x02,
	0xa4,
	0xff,
	0xae,
	0xf0,
	0x12,
	0x14,
	0x91,
	0xa3,
	0xe0,
	0xb4,
	0x31,
	0x07,
	0xea,
	0xc3,
	0x13,
	0xfa,
	0xeb,
	0x13,
	0xfb,
	0x90,
	0x38,
	0x14,
	0xe0,
	0xb4,
	0x71,
	0x0f,
	0xeb,
	0xae,
	0x02,
	0x78,
	0x02,
	0xce,
	0xc3,
	0x13,
	0xce,
	0x13,
	0xd8,
	0xf9,
	0xfb,
	0xaa,
	0x06,
	0x90,
	0x38,
};
static kal_uint8 addr_data_pair10[255] = {
	0x88,
	0xe4,
	0x15,
	0xe0,
	0xb4,
	0x31,
	0x0b,
	0xe5,
	0x0c,
	0xc3,
	0x13,
	0xf5,
	0x0c,
	0xe5,
	0x0d,
	0x13,
	0xf5,
	0x0d,
	0x90,
	0x38,
	0x15,
	0xe0,
	0xb4,
	0x71,
	0x11,
	0xe5,
	0x0d,
	0xae,
	0x0c,
	0x78,
	0x02,
	0xce,
	0xc3,
	0x13,
	0xce,
	0x13,
	0xd8,
	0xf9,
	0xf5,
	0x0d,
	0x8e,
	0x0c,
	0xea,
	0xc4,
	0xf8,
	0x54,
	0xf0,
	0xc8,
	0x68,
	0xfa,
	0xeb,
	0xc4,
	0x54,
	0x0f,
	0x48,
	0xfb,
	0xe5,
	0x0c,
	0xc4,
	0xf8,
	0x54,
	0xf0,
	0xc8,
	0x68,
	0xf5,
	0x0c,
	0xe5,
	0x0d,
	0xc4,
	0x54,
	0x0f,
	0x48,
	0xf5,
	0x0d,
	0xe5,
	0x41,
	0x54,
	0x10,
	0xd3,
	0x94,
	0x00,
	0x40,
	0x08,
	0x85,
	0x42,
	0x4a,
	0x85,
	0x43,
	0x4b,
	0x80,
	0x0b,
	0x30,
	0x39,
	0x04,
	0x7f,
	0x16,
	0x80,
	0x02,
	0x7f,
	0x1e,
	0x8f,
	0x4b,
	0xaf,
	0x4a,
	0x12,
	0x14,
	0x76,
	0xaf,
	0x4b,
	0x7e,
	0x00,
	0xac,
	0x0c,
	0xad,
	0x0d,
	0x12,
	0x14,
	0x84,
	0xfd,
	0x7c,
	0x00,
	0xae,
	0x0e,
	0xaf,
	0x0f,
	0x12,
	0x0a,
	0x9b,
	0x8f,
	0x4a,
	0xae,
	0x10,
	0xaf,
	0x11,
	0x7c,
	0x00,
	0x30,
	0x39,
	0x04,
	0x7d,
	0x2d,
	0x80,
	0x02,
	0x7d,
	0x3c,
	0x12,
	0x0a,
	0x9b,
	0x8f,
	0x4b,
	0x8b,
	0x49,
	0x85,
	0x0d,
	0x48,
	0xaf,
	0x4c,
	0x12,
	0x14,
	0x76,
	0xaf,
	0x4d,
	0x7e,
	0x00,
	0x12,
	0x14,
	0x84,
	0xfb,
	0xae,
	0x0e,
	0xaf,
	0x0f,
	0xfd,
	0x7c,
	0x00,
	0x12,
	0x0a,
	0x9b,
	0x8f,
	0x4c,
	0xae,
	0x10,
	0xaf,
	0x11,
	0xad,
	0x03,
	0x7c,
	0x00,
	0x12,
	0x0a,
	0x9b,
	0x8f,
	0x4d,
	0xe5,
	0x4c,
	0x75,
	0xf0,
	0x02,
	0xa4,
	0xad,
	0x49,
	0x7c,
	0x00,
	0xd3,
	0x9d,
	0x74,
	0x80,
	0xf8,
	0x65,
	0xf0,
	0x98,
	0x40,
	0x05,
	0xe5,
	0x49,
	0x13,
	0xf5,
	0x4c,
	0xe5,
	0x4d,
	0x75,
	0xf0,
	0x02,
	0xa4,
	0xd3,
	0x95,
	0x48,
	0x74,
	0x80,
	0xf8,
	0x65,
	0xf0,
	0x98,
	0x40,
	0x05,
	0xe5,
	0x48,
	0x13,
	0xf5,
	0x4d,
	0xe5,
	0x4a,
	0xc3,
	0x95,
	0x4c,
	0x50,
	0x03,
	0x85,
	0x4c,
	0x4a,
	0xe5,
	0x4b,
	0xc3,
	0x95,
	0x4d,

};
static kal_uint8 addr_data_pair11[255] = {
	0x89,
	0xe1,
	0x50,
	0x03,
	0x85,
	0x4d,
	0x4b,
	0xe5,
	0x4a,
	0x25,
	0x4c,
	0xff,
	0xe4,
	0x33,
	0xfe,
	0xd3,
	0xef,
	0x9d,
	0xec,
	0x64,
	0x80,
	0xf8,
	0xee,
	0x64,
	0x80,
	0x98,
	0x40,
	0x06,
	0xe5,
	0x49,
	0x95,
	0x4c,
	0xf5,
	0x4a,
	0xe5,
	0x4b,
	0x25,
	0x4d,
	0xff,
	0xe4,
	0x33,
	0xfe,
	0xd3,
	0xef,
	0x95,
	0x48,
	0x74,
	0x80,
	0xf8,
	0x6e,
	0x98,
	0x40,
	0x06,
	0xe5,
	0x48,
	0x95,
	0x4d,
	0xf5,
	0x4b,
	0xc3,
	0xe5,
	0x4a,
	0x95,
	0x4c,
	0xf5,
	0x0a,
	0xc3,
	0xe5,
	0x4b,
	0x95,
	0x4d,
	0xf5,
	0x0b,
	0xe5,
	0x4a,
	0x25,
	0x4c,
	0xf9,
	0xe5,
	0x4b,
	0x25,
	0x4d,
	0xfd,
	0x90,
	0x60,
	0x01,
	0xe4,
	0xf0,
	0xa3,
	0xf0,
	0xa3,
	0xe5,
	0x49,
	0xf0,
	0xa3,
	0xe5,
	0x48,
	0xf0,
	0x7c,
	0x01,
	0xec,
	0x75,
	0xf0,
	0x04,
	0xa4,
	0xff,
	0x24,
	0x01,
	0x12,
	0x14,
	0x9d,
	0xe5,
	0x0a,
	0xf0,
	0xef,
	0x24,
	0x02,
	0xff,
	0xee,
	0x34,
	0x60,
	0x8f,
	0x82,
	0xf5,
	0x83,
	0xe5,
	0x0b,
	0xf0,
	0xec,
	0x75,
	0xf0,
	0x04,
	0xa4,
	0xff,
	0x24,
	0x03,
	0x12,
	0x14,
	0x9d,
	0xe9,
	0xf0,
	0xef,
	0x24,
	0x04,
	0xff,
	0xee,
	0x34,
	0x60,
	0x8f,
	0x82,
	0xf5,
	0x83,
	0xed,
	0xf0,
	0x0c,
	0xbc,
	0x05,
	0xc6,
	0x90,
	0x30,
	0x01,
	0xe0,
	0x44,
	0x40,
	0xf0,
	0xe0,
	0x54,
	0xbf,
	0xf0,
	0x22,
	0xef,
	0x8d,
	0xf0,
	0xa4,
	0xa8,
	0xf0,
	0xcf,
	0x8c,
	0xf0,
	0xa4,
	0x28,
	0xce,
	0x8d,
	0xf0,
	0xa4,
	0x2e,
	0xfe,
	0x22,
	0xbc,
	0x00,
	0x0b,
	0xbe,
	0x00,
	0x29,
	0xef,
	0x8d,
	0xf0,
	0x84,
	0xff,
	0xad,
	0xf0,
	0x22,
	0xe4,
	0xcc,
	0xf8,
	0x75,
	0xf0,
	0x08,
	0xef,
	0x2f,
	0xff,
	0xee,
	0x33,
	0xfe,
	0xec,
	0x33,
	0xfc,
	0xee,
	0x9d,
	0xec,
	0x98,
	0x40,
	0x05,
	0xfc,
	0xee,
	0x9d,
	0xfe,
	0x0f,
	0xd5,
	0xf0,
	0xe9,
	0xe4,
	0xce,
	0xfd,
	0x22,
	0xed,
	0xf8,
	0xf5,
	0xf0,
	0xee,
	0x84,
	0x20,
	0xd2,
	0x1c,
	0xfe,
	0xad,
	0xf0,
	0x75,
	0xf0,
	0x08,
	0xef,
	0x2f,
	0xff,
	0xed,
	0x33,
};
static kal_uint8 addr_data_pair12[255] = {
	0x8a,
	0xde,
	0xfd,
	0x40,
	0x07,
	0x98,
	0x50,
	0x06,
	0xd5,
	0xf0,
	0xf2,
	0x22,
	0xc3,
	0x98,
	0xfd,
	0x0f,
	0xd5,
	0xf0,
	0xea,
	0x22,
	0xe8,
	0x8f,
	0xf0,
	0xa4,
	0xcc,
	0x8b,
	0xf0,
	0xa4,
	0x2c,
	0xfc,
	0xe9,
	0x8e,
	0xf0,
	0xa4,
	0x2c,
	0xfc,
	0x8a,
	0xf0,
	0xed,
	0xa4,
	0x2c,
	0xfc,
	0xea,
	0x8e,
	0xf0,
	0xa4,
	0xcd,
	0xa8,
	0xf0,
	0x8b,
	0xf0,
	0xa4,
	0x2d,
	0xcc,
	0x38,
	0x25,
	0xf0,
	0xfd,
	0xe9,
	0x8f,
	0xf0,
	0xa4,
	0x2c,
	0xcd,
	0x35,
	0xf0,
	0xfc,
	0xeb,
	0x8e,
	0xf0,
	0xa4,
	0xfe,
	0xa9,
	0xf0,
	0xeb,
	0x8f,
	0xf0,
	0xa4,
	0xcf,
	0xc5,
	0xf0,
	0x2e,
	0xcd,
	0x39,
	0xfe,
	0xe4,
	0x3c,
	0xfc,
	0xea,
	0xa4,
	0x2d,
	0xce,
	0x35,
	0xf0,
	0xfd,
	0xe4,
	0x3c,
	0xfc,
	0x22,
	0x75,
	0xf0,
	0x08,
	0x75,
	0x82,
	0x00,
	0xef,
	0x2f,
	0xff,
	0xee,
	0x33,
	0xfe,
	0xcd,
	0x33,
	0xcd,
	0xcc,
	0x33,
	0xcc,
	0xc5,
	0x82,
	0x33,
	0xc5,
	0x82,
	0x9b,
	0xed,
	0x9a,
	0xec,
	0x99,
	0xe5,
	0x82,
	0x98,
	0x40,
	0x0c,
	0xf5,
	0x82,
	0xee,
	0x9b,
	0xfe,
	0xed,
	0x9a,
	0xfd,
	0xec,
	0x99,
	0xfc,
	0x0f,
	0xd5,
	0xf0,
	0xd6,
	0xe4,
	0xce,
	0xfb,
	0xe4,
	0xcd,
	0xfa,
	0xe4,
	0xcc,
	0xf9,
	0xa8,
	0x82,
	0x22,
	0xb8,
	0x00,
	0xc1,
	0xb9,
	0x00,
	0x59,
	0xba,
	0x00,
	0x2d,
	0xec,
	0x8b,
	0xf0,
	0x84,
	0xcf,
	0xce,
	0xcd,
	0xfc,
	0xe5,
	0xf0,
	0xcb,
	0xf9,
	0x78,
	0x18,
	0xef,
	0x2f,
	0xff,
	0xee,
	0x33,
	0xfe,
	0xed,
	0x33,
	0xfd,
	0xec,
	0x33,
	0xfc,
	0xeb,
	0x33,
	0xfb,
	0x10,
	0xd7,
	0x03,
	0x99,
	0x40,
	0x04,
	0xeb,
	0x99,
	0xfb,
	0x0f,
	0xd8,
	0xe5,
	0xe4,
	0xf9,
	0xfa,
	0x22,
	0x78,
	0x18,
	0xef,
	0x2f,
	0xff,
	0xee,
	0x33,
	0xfe,
	0xed,
	0x33,
	0xfd,
	0xec,
	0x33,
	0xfc,
	0xc9,
	0x33,
	0xc9,
	0x10,
	0xd7,
	0x05,
	0x9b,
	0xe9,
	0x9a,
	0x40,
	0x07,
	0xec,
	0x9b,
	0xfc,
	0xe9,
	0x9a,
	0xf9,
	0x0f,
	0xd8,
	0xe0,
	0xe4,
	0xc9,
	0xfa,
	0xe4,
	0xcc,
	0xfb,
	0x22,
	0x75,
};
static kal_uint8 addr_data_pair13[255] = {
	0x8b,
	0xdb,
	0xf0,
	0x10,
	0xef,
	0x2f,
	0xff,
	0xee,
	0x33,
	0xfe,
	0xed,
	0x33,
	0xfd,
	0xcc,
	0x33,
	0xcc,
	0xc8,
	0x33,
	0xc8,
	0x10,
	0xd7,
	0x07,
	0x9b,
	0xec,
	0x9a,
	0xe8,
	0x99,
	0x40,
	0x0a,
	0xed,
	0x9b,
	0xfd,
	0xec,
	0x9a,
	0xfc,
	0xe8,
	0x99,
	0xf8,
	0x0f,
	0xd5,
	0xf0,
	0xda,
	0xe4,
	0xcd,
	0xfb,
	0xe4,
	0xcc,
	0xfa,
	0xe4,
	0xc8,
	0xf9,
	0x22,
	0xeb,
	0x9f,
	0xf5,
	0xf0,
	0xea,
	0x9e,
	0x42,
	0xf0,
	0xe9,
	0x9d,
	0x42,
	0xf0,
	0xe8,
	0x9c,
	0x45,
	0xf0,
	0x22,
	0xe8,
	0x60,
	0x0f,
	0xec,
	0xc3,
	0x13,
	0xfc,
	0xed,
	0x13,
	0xfd,
	0xee,
	0x13,
	0xfe,
	0xef,
	0x13,
	0xff,
	0xd8,
	0xf1,
	0x22,
	0xe8,
	0x60,
	0x0f,
	0xef,
	0xc3,
	0x33,
	0xff,
	0xee,
	0x33,
	0xfe,
	0xed,
	0x33,
	0xfd,
	0xec,
	0x33,
	0xfc,
	0xd8,
	0xf1,
	0x22,
	0xe4,
	0x93,
	0xfc,
	0x74,
	0x01,
	0x93,
	0xfd,
	0x74,
	0x02,
	0x93,
	0xfe,
	0x74,
	0x03,
	0x93,
	0xff,
	0x22,
	0xa4,
	0x25,
	0x82,
	0xf5,
	0x82,
	0xe5,
	0xf0,
	0x35,
	0x83,
	0xf5,
	0x83,
	0x22,
	0xd0,
	0x83,
	0xd0,
	0x82,
	0xf8,
	0xe4,
	0x93,
	0x70,
	0x12,
	0x74,
	0x01,
	0x93,
	0x70,
	0x0d,
	0xa3,
	0xa3,
	0x93,
	0xf8,
	0x74,
	0x01,
	0x93,
	0xf5,
	0x82,
	0x88,
	0x83,
	0xe4,
	0x73,
	0x74,
	0x02,
	0x93,
	0x68,
	0x60,
	0xef,
	0xa3,
	0xa3,
	0xa3,
	0x80,
	0xdf,
	0x90,
	0x0e,
	0x9a,
	0x12,
	0x0f,
	0x65,
	0x78,
	0x98,
	0xe6,
	0xf5,
	0x0f,
	0x08,
	0xe6,
	0xf5,
	0x10,
	0xe4,
	0xfd,
	0xed,
	0xc3,
	0x94,
	0x08,
	0x50,
	0x18,
	0xe5,
	0x10,
	0x94,
	0x00,
	0xe5,
	0x0f,
	0x94,
	0x78,
	0x50,
	0x0e,
	0xe5,
	0x10,
	0x25,
	0xe0,
	0xf5,
	0x10,
	0xe5,
	0x0f,
	0x33,
	0xf5,
	0x0f,
	0x1d,
	0x80,
	0xe2,
	0xc3,
	0x74,
	0x07,
	0x9d,
	0xfd,
	0xc3,
	0x94,
	0x00,
	0x50,
	0x02,
	0xe4,
	0xfd,
	0x12,
	0x0e,
	0xca,
	0xed,
	0x90,
	0x0d,
	0xd5,
	0x12,
	0x0f,
	0x8a,
	0x12,
	0x0a,
	0xf0,
	0x12,
	0x0e,
	0xc2,
	0xc0,
	0x00,
	0x78,
	0xd0,
	0xe6,
	0x12,
	0x0f,
};
static kal_uint8 addr_data_pair14[255] = {
	0x8c,
	0xd8,
	0x25,
	0xff,
	0x33,
	0x95,
	0xe0,
	0xfe,
	0x74,
	0xc4,
	0x2f,
	0xf5,
	0x82,
	0x74,
	0x0d,
	0x12,
	0x0f,
	0x39,
	0xd0,
	0x00,
	0x12,
	0x0a,
	0xf0,
	0x12,
	0x0e,
	0xc2,
	0xc0,
	0x00,
	0xc0,
	0x01,
	0xc3,
	0x79,
	0xbf,
	0xe7,
	0x78,
	0xbe,
	0x96,
	0x12,
	0x0f,
	0x25,
	0xff,
	0x33,
	0x95,
	0xe0,
	0xfe,
	0x74,
	0xb3,
	0x2f,
	0xf5,
	0x82,
	0x74,
	0x0d,
	0x12,
	0x0f,
	0x39,
	0xd0,
	0x01,
	0xd0,
	0x00,
	0x12,
	0x0e,
	0xb2,
	0x90,
	0x0d,
	0xee,
	0x12,
	0x0f,
	0x89,
	0x12,
	0x0e,
	0xb2,
	0xc0,
	0x00,
	0xc0,
	0x01,
	0xc3,
	0x79,
	0xcf,
	0xe7,
	0x78,
	0xce,
	0x96,
	0x12,
	0x0f,
	0x25,
	0xff,
	0x33,
	0x95,
	0xe0,
	0xfe,
	0x74,
	0xdd,
	0x2f,
	0xf5,
	0x82,
	0x74,
	0x0d,
	0x12,
	0x0f,
	0x39,
	0xd0,
	0x01,
	0xd0,
	0x00,
	0x12,
	0x0f,
	0x44,
	0x78,
	0x0e,
	0x12,
	0x0e,
	0xbf,
	0xc0,
	0x00,
	0x78,
	0x98,
	0xe6,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0xe4,
	0xfc,
	0xfd,
	0xd0,
	0x00,
	0x12,
	0x0f,
	0x44,
	0x78,
	0x0e,
	0x12,
	0x0c,
	0x1e,
	0x12,
	0x0f,
	0x47,
	0x90,
	0x0e,
	0x9b,
	0x12,
	0x0f,
	0x89,
	0x12,
	0x0e,
	0xca,
	0xc3,
	0x12,
	0x0c,
	0x0d,
	0x50,
	0x06,
	0x90,
	0x0e,
	0x9b,
	0x12,
	0x0f,
	0x65,
	0x78,
	0xc9,
	0xe6,
	0x12,
	0x0e,
	0xdf,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0xe4,
	0xfc,
	0xfd,
	0x12,
	0x0e,
	0xca,
	0xd3,
	0x12,
	0x0c,
	0x0d,
	0x40,
	0x07,
	0xe4,
	0xf5,
	0x0f,
	0xf5,
	0x10,
	0x80,
	0x1a,
	0x85,
	0x0d,
	0x0f,
	0x85,
	0x0e,
	0x10,
	0x78,
	0xc9,
	0xe6,
	0x25,
	0xe0,
	0x24,
	0x57,
	0xf8,
	0xc3,
	0xe6,
	0x95,
	0x10,
	0xf5,
	0x10,
	0x18,
	0xe6,
	0x95,
	0x0f,
	0xf5,
	0x0f,
	0x78,
	0x9c,
	0xa6,
	0x0f,
	0x08,
	0xa6,
	0x10,
	0x22,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
};
static kal_uint8 addr_data_pair15[255] = {
	0x8d,
	0xd5,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x10,
	0x18,
	0x20,
	0x28,
	0x30,
	0x38,
	0x40,
	0x48,
	0x50,
	0x58,
	0x60,
	0x68,
	0x70,
	0x78,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x80,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x13,
	0x04,
	0x26,
	0x15,
	0x01,
	0x36,
	0x4f,
	0x56,
	0x54,
	0x20,
	0x20,
	0x20,
	0x20,
	0x20,
	0x43,
	0x01,
	0x10,
	0x00,
	0x56,
	0x45,
	0x1a,
	0x30,
	0x29,
	0x7e,
	0x00,
	0x30,
	0x04,
	0x20,
	0xdf,
	0x30,
	0x05,
	0x40,
	0xbf,
	0x50,
	0x03,
	0x00,
	0xfd,
	0x50,
	0x27,
	0x01,
	0xfe,
	0x60,
	0x00,
	0x13,
	0x00,
	0x36,
	0x06,
	0x07,
	0x00,
	0x3f,
	0x05,
	0x30,
	0x00,
	0x3f,
	0x06,
	0x22,
	0x00,
	0x3f,
	0x08,
	0x00,
	0x00,
	0x3f,
	0x09,
	0x00,
	0x00,
	0x3f,
	0x0a,
	0x00,
	0x00,
	0x3f,
	0x0b,
	0x0f,
	0x00,
	0x3f,
	0x01,
	0x2a,
	0x00,
	0x3f,
	0x02,
	0x00,
	0x00,
	0x30,
	0x01,
	0x40,
	0xbf,
	0x30,
	0x01,
	0x00,
	0xbf,
	0x30,
	0x29,
	0x70,
	0x00,
	0x3a,
	0x00,
	0x00,
	0xff,
	0x3a,
	0x00,
	0x00,
	0xff,
	0x36,
	0x03,
	0x36,
	0x02,
	0x41,
	0x44,
	0x58,
	0x20,
	0x18,
	0x10,
	0x0a,
	0x04,
	0x04,
	0x00,
	0x03,
	0xff,
	0x64,
	0x00,
	0x00,
	0x80,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x00,
	0x02,
	0x04,
	0x06,
	0x06,
	0x00,
	0x02,
	0x65,
	0x00,
	0x7a,
	0x50,
	0x28,
	0x1e,
	0x08,
	0x08,
	0x01,
	0x1e,
	0x1e,
	0x1e,
	0x1e,
	0x68,
	0x68,
	0x68,
	0x68,
	0x03,
	0x05,
	0x0a,
	0x08,
	0x10,
	0x01,
	0x0a,
	0x06,
	0x06,
	0x05,
	0x05,
	0x05,
	0x05,
	0x04,
	0x04,
	0x04,
	0x04,
	0x04,
	0xfc,
	0xfc,
	0xfc,
	0xfc,
	0xfc,
	0xfc,
	0x00,
	0xa5,
	0x5a,
	0x00,
	0x12,
	0x0a,
	0xf0,
	0x8f,
	0x0e,
	0x8e,
	0x0d,
	0x8d,
	0x0c,
	0x8c,
	0x0b,
	0x78,
	0x07,
	0x12,
	0x0c,
	0x1e,
	0x8f,
	0x0e,
	0x8e,
	0x0d,
	0x8d,
	0x0c,
	0x8c,
	0x0b,
	0xab,
	0x0e,
	0xaa,
	0x0d,
	0xa9,
	0x0c,
	0xa8,
	0x0b,
};
static kal_uint8 addr_data_pair16[255] = {
	0x8e,
	0xd2,
	0x22,
	0xef,
	0x25,
	0xe0,
	0x24,
	0x56,
	0xf8,
	0xe6,
	0xfc,
	0x08,
	0xe6,
	0xfd,
	0xee,
	0x25,
	0xe0,
	0x24,
	0x56,
	0xf8,
	0xe6,
	0x22,
	0x78,
	0xce,
	0xf9,
	0xc3,
	0xe7,
	0x64,
	0x80,
	0xf5,
	0xf0,
	0xe6,
	0x64,
	0x80,
	0x95,
	0xf0,
	0x22,
	0x78,
	0xcb,
	0xe6,
	0x78,
	0x9d,
	0x25,
	0xe0,
	0x24,
	0x57,
	0xf9,
	0xd3,
	0xe7,
	0x96,
	0x19,
	0xe7,
	0x18,
	0x96,
	0x22,
	0x78,
	0xcf,
	0xf9,
	0xd3,
	0xe7,
	0x64,
	0x80,
	0xf5,
	0xf0,
	0xe6,
	0x64,
	0x80,
	0x95,
	0xf0,
	0x22,
	0xd3,
	0x78,
	0xc1,
	0xe6,
	0x64,
	0x80,
	0x94,
	0x80,
	0x22,
	0x78,
	0xc1,
	0xe6,
	0xf4,
	0x04,
	0xff,
	0xa2,
	0xe7,
	0x13,
	0xa2,
	0xe7,
	0x13,
	0x22,
	0xa6,
	0x06,
	0x08,
	0xa6,
	0x07,
	0x78,
	0x9a,
	0xe6,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0x22,
	0x3e,
	0xf5,
	0x83,
	0xe4,
	0x93,
	0xff,
	0xe4,
	0xfc,
	0xfd,
	0xfe,
	0x22,
	0x12,
	0x0a,
	0xf0,
	0x8f,
	0x0e,
	0x8e,
	0x0d,
	0x8d,
	0x0c,
	0x8c,
	0x0b,
	0x22,
	0x78,
	0xc9,
	0xe6,
	0x24,
	0x9e,
	0xf8,
	0xe6,
	0x78,
	0xd0,
	0xf6,
	0x22,
	0xc3,
	0xe6,
	0x64,
	0x80,
	0xf8,
	0xef,
	0x64,
	0x80,
	0x98,
	0x22,
	0xe4,
	0x93,
	0xff,
	0xe4,
	0x8f,
	0x0e,
	0xf5,
	0x0d,
	0xf5,
	0x0c,
	0xf5,
	0x0b,
	0x22,
	0x78,
	0xc1,
	0xe6,
	0xf4,
	0x04,
	0xf6,
	0x22,
	0xfa,
	0x08,
	0xe6,
	0xc3,
	0x9d,
	0xea,
	0x9c,
	0x22,
	0xf6,
	0xd3,
	0xe6,
	0x64,
	0x80,
	0x94,
	0x80,
	0x22,
	0xe4,
	0x93,
	0xff,
	0xe4,
	0xfc,
	0xfd,
	0xfe,
	0x22,
	0x78,
	0x98,
	0xa6,
	0x06,
	0x08,
	0xa6,
	0x07,
	0x22,
	0x78,
	0xc5,
	0xe6,
	0x24,
	0x9e,
	0xf8,
	0x22,
	0x78,
	0xd0,
	0xe6,
	0x78,
	0xc4,
	0xf6,
	0x22,
	0x85,
	0x28,
	0x46,
	0x90,
	0x30,
	0x24,
	0xe0,
	0xf5,
	0x42,
	0xa3,
	0xe0,
	0xf5,
	0x43,
	0xa3,
	0xe0,
	0xf5,
	0x44,
	0xa3,
	0xe0,
	0xf5,
	0x45,
	0xa3,
	0xe0,
	0xf5,
	0x41,
	0xd2,
	0x35,
	0xe5,
	0x46,
	0x12,
	0x0c,
	0x60,
	0x0f,
	0xf2,
	0x03,
	0x0f,
	0xff,
	0x04,
	0x10,
	0x10,
};
static kal_uint8 addr_data_pair17[255] = {
	0x8f,
	0xcf,
	0x05,
	0x10,
	0x13,
	0x06,
	0x10,
	0x63,
	0x07,
	0x10,
	0x1c,
	0x08,
	0x10,
	0x31,
	0x12,
	0x10,
	0x40,
	0x1a,
	0x10,
	0x4b,
	0x1b,
	0x10,
	0x31,
	0x80,
	0x10,
	0x2c,
	0x81,
	0x10,
	0x63,
	0xdc,
	0x10,
	0x53,
	0xec,
	0x00,
	0x00,
	0x10,
	0x7e,
	0x12,
	0x15,
	0x4e,
	0xd2,
	0x37,
	0xd2,
	0x01,
	0xc2,
	0x02,
	0x12,
	0x15,
	0x53,
	0x22,
	0xd2,
	0x34,
	0xd2,
	0x37,
	0xe5,
	0x42,
	0xd3,
	0x94,
	0x00,
	0x40,
	0x03,
	0x12,
	0x15,
	0x4e,
	0xd2,
	0x03,
	0x22,
	0xd2,
	0x03,
	0x22,
	0xc2,
	0x03,
	0x20,
	0x01,
	0x66,
	0x30,
	0x02,
	0x48,
	0x22,
	0xc2,
	0x01,
	0xc2,
	0x02,
	0xc2,
	0x03,
	0x12,
	0x13,
	0xc5,
	0x75,
	0x1d,
	0x70,
	0xd2,
	0x36,
	0x80,
	0x37,
	0x43,
	0x41,
	0x10,
	0x80,
	0x0a,
	0xe5,
	0x41,
	0x70,
	0x03,
	0xc3,
	0x80,
	0x01,
	0xd3,
	0x92,
	0x39,
	0x12,
	0x08,
	0x60,
	0x80,
	0x23,
	0x85,
	0x45,
	0x4e,
	0x85,
	0x41,
	0x4f,
	0x12,
	0x12,
	0xaf,
	0x80,
	0x18,
	0x85,
	0x4e,
	0x45,
	0x85,
	0x4f,
	0x41,
	0x80,
	0x10,
	0xc2,
	0xaf,
	0x85,
	0x2a,
	0x42,
	0x85,
	0x2b,
	0x43,
	0x85,
	0x2c,
	0x44,
	0x85,
	0x2d,
	0x45,
	0xd2,
	0xaf,
	0x90,
	0x30,
	0x24,
	0xe5,
	0x42,
	0xf0,
	0xa3,
	0xe5,
	0x43,
	0xf0,
	0xa3,
	0xe5,
	0x44,
	0xf0,
	0xa3,
	0xe5,
	0x45,
	0xf0,
	0xa3,
	0xe5,
	0x41,
	0xf0,
	0x90,
	0x30,
	0x23,
	0xe4,
	0xf0,
	0x22,
	0x78,
	0xc8,
	0xe6,
	0xf5,
	0x0b,
	0x18,
	0xe6,
	0xf5,
	0x0c,
	0xe4,
	0xf5,
	0x0d,
	0xf5,
	0x0e,
	0xf5,
	0x0f,
	0xf9,
	0x78,
	0xc9,
	0xe6,
	0x08,
	0xf6,
	0x78,
	0xc7,
	0xe6,
	0xff,
	0x04,
	0xfe,
	0x78,
	0xc8,
	0x12,
	0x0f,
	0x5b,
	0x50,
	0x54,
	0x12,
	0x0e,
	0xd3,
	0xfa,
	0x08,
	0xe6,
	0xd3,
	0x9d,
	0xea,
	0x9c,
	0x40,
	0x14,
	0x05,
	0x0f,
	0xd3,
	0xe5,
	0x0e,
	0x64,
	0x80,
	0xf8,
	0xe9,
	0x64,
	0x80,
	0x98,
	0x40,
	0x02,
	0x89,
	0x0e,
	0xe4,
	0xf9,
	0x80,
	0x1b,
	0x12,
	0x0e,
	0xd3,
	0x12,
	0x0f,
	0x79,
	0x50,
	0x13,
	0x09,
	0xe5,
};
static kal_uint8 addr_data_pair18[255] = {
	0x90,
	0xcc,
	0x0d,
	0x64,
	0x80,
	0xf8,
	0xe5,
	0x0f,
	0x64,
	0x80,
	0x98,
	0x40,
	0x03,
	0x85,
	0x0f,
	0x0d,
	0xe4,
	0xf5,
	0x0f,
	0x78,
	0xc9,
	0xe6,
	0x12,
	0x0e,
	0xd4,
	0xfa,
	0x08,
	0xe6,
	0xb5,
	0x05,
	0x08,
	0xea,
	0xb5,
	0x04,
	0x04,
	0x78,
	0xca,
	0xa6,
	0x06,
	0x0f,
	0x0e,
	0x02,
	0x10,
	0x9b,
	0x78,
	0xc7,
	0xe6,
	0xf5,
	0x0c,
	0xe6,
	0x04,
	0xff,
	0x78,
	0xc9,
	0x12,
	0x0f,
	0x5b,
	0x50,
	0x17,
	0xe5,
	0x0c,
	0x12,
	0x0e,
	0xdf,
	0xfc,
	0x08,
	0xe6,
	0xfd,
	0xef,
	0x12,
	0x0e,
	0xdf,
	0x12,
	0x0f,
	0x79,
	0x50,
	0x02,
	0x8f,
	0x0c,
	0x0f,
	0x80,
	0xe2,
	0x78,
	0xc8,
	0xe6,
	0xf5,
	0x0b,
	0xe6,
	0x14,
	0xff,
	0x78,
	0xca,
	0xd3,
	0x12,
	0x0f,
	0x5c,
	0x40,
	0x17,
	0xe5,
	0x0b,
	0x12,
	0x0e,
	0xdf,
	0xfc,
	0x08,
	0xe6,
	0xfd,
	0xef,
	0x12,
	0x0e,
	0xdf,
	0x12,
	0x0f,
	0x79,
	0x50,
	0x02,
	0x8f,
	0x0b,
	0x1f,
	0x80,
	0xe1,
	0x78,
	0xcb,
	0xa6,
	0x0c,
	0x08,
	0xa6,
	0x0b,
	0x22,
	0xe5,
	0x0a,
	0x75,
	0xf0,
	0x03,
	0xa4,
	0x24,
	0xb3,
	0x25,
	0x0b,
	0xf8,
	0xe6,
	0x22,
	0xad,
	0x11,
	0xac,
	0x10,
	0xfa,
	0xf9,
	0xf8,
	0x12,
	0x0a,
	0xf0,
	0x8f,
	0x13,
	0x8e,
	0x12,
	0x8d,
	0x11,
	0x8c,
	0x10,
	0xab,
	0x0f,
	0xaa,
	0x0e,
	0xa9,
	0x0d,
	0xa8,
	0x0c,
	0x22,
	0xe5,
	0x0a,
	0x75,
	0xf0,
	0x08,
	0xa4,
	0x24,
	0x5a,
	0xf8,
	0xe5,
	0x0b,
	0x25,
	0xe0,
	0x28,
	0x22,
	0xa6,
	0x04,
	0x08,
	0xa6,
	0x05,
	0xef,
	0x25,
	0xe0,
	0x25,
	0xe0,
	0x24,
	0x2c,
	0xf8,
	0xe6,
	0xfe,
	0x08,
	0xe6,
	0xff,
	0x22,
	0xe5,
	0x0b,
	0x93,
	0xff,
	0xe4,
	0xfc,
	0xfd,
	0xfe,
	0x12,
	0x0a,
	0xf0,
	0x8f,
	0x0f,
	0x8e,
	0x0e,
	0x8d,
	0x0d,
	0x8c,
	0x0c,
	0x22,
	0x90,
	0x0e,
	0x8d,
	0xe4,
	0x93,
	0xff,
	0x25,
	0xe0,
	0x25,
	0xe0,
	0x24,
	0x2a,
	0xf8,
	0xe6,
	0xfc,
	0x08,
	0xe6,
	0xfd,
	0x22,
	0x78,
	0xaa,
	0xe6,
	0x75,
	0xf0,
	0x08,
	0xa4,
	0x22,
	0xf8,
	0xa6,
	0x33,
	0x78,
	0xaa,
};
static kal_uint8 addr_data_pair19[255] = {
	0x91,
	0xc9,
	0xe6,
	0x75,
	0xf0,
	0x03,
	0xa4,
	0x22,
	0xe5,
	0x0b,
	0x25,
	0xe0,
	0x24,
	0x5a,
	0xf8,
	0xe6,
	0x22,
	0x08,
	0xa6,
	0x2a,
	0x08,
	0xa6,
	0x2b,
	0x08,
	0xa6,
	0x2c,
	0x08,
	0xa6,
	0x2d,
	0x22,
	0xe5,
	0x0b,
	0x24,
	0x04,
	0xff,
	0x74,
	0x01,
	0xa8,
	0x07,
	0x08,
	0x22,
	0xe4,
	0x8f,
	0x0f,
	0x8e,
	0x0e,
	0xf5,
	0x0d,
	0xf5,
	0x0c,
	0x22,
	0x74,
	0xb3,
	0x25,
	0x0b,
	0xf8,
	0xe6,
	0x22,
	0xc0,
	0xe0,
	0xc0,
	0x83,
	0xc0,
	0x82,
	0xc0,
	0xd0,
	0x90,
	0x3f,
	0x0c,
	0xe0,
	0xf5,
	0x08,
	0xe5,
	0x08,
	0x30,
	0xe3,
	0x60,
	0x30,
	0x37,
	0x52,
	0x90,
	0x60,
	0x19,
	0xe0,
	0xf5,
	0x2a,
	0xa3,
	0xe0,
	0xf5,
	0x2b,
	0x90,
	0x60,
	0x1d,
	0xe0,
	0xf5,
	0x2c,
	0xa3,
	0xe0,
	0xf5,
	0x2d,
	0x90,
	0x60,
	0x21,
	0xe0,
	0xf5,
	0x2e,
	0xa3,
	0xe0,
	0xf5,
	0x2f,
	0x90,
	0x60,
	0x25,
	0xe0,
	0xf5,
	0x30,
	0xa3,
	0xe0,
	0xf5,
	0x31,
	0x30,
	0x01,
	0x06,
	0x30,
	0x34,
	0x03,
	0xd3,
	0x80,
	0x01,
	0xc3,
	0x92,
	0x09,
	0x30,
	0x02,
	0x06,
	0x30,
	0x34,
	0x03,
	0xd3,
	0x80,
	0x01,
	0xc3,
	0x92,
	0x0a,
	0x30,
	0x34,
	0x0c,
	0x30,
	0x03,
	0x09,
	0x20,
	0x02,
	0x06,
	0x20,
	0x01,
	0x03,
	0xd3,
	0x80,
	0x01,
	0xc3,
	0x92,
	0x0b,
	0x90,
	0x30,
	0x01,
	0xe0,
	0x44,
	0x40,
	0xf0,
	0xe0,
	0x54,
	0xbf,
	0xf0,
	0xe5,
	0x08,
	0x30,
	0xe1,
	0x14,
	0x30,
	0x35,
	0x11,
	0x90,
	0x30,
	0x22,
	0xe0,
	0xf5,
	0x28,
	0xe4,
	0xf0,
	0x30,
	0x00,
	0x03,
	0xd3,
	0x80,
	0x01,
	0xc3,
	0x92,
	0x08,
	0xe5,
	0x08,
	0x30,
	0xe2,
	0x0e,
	0x90,
	0x51,
	0xa5,
	0xe0,
	0xf5,
	0x33,
	0xa3,
	0xe0,
	0xf5,
	0x34,
	0xa3,
	0xe0,
	0xf5,
	0x35,
	0x90,
	0x3f,
	0x0c,
	0xe5,
	0x08,
	0xf0,
	0xd0,
	0xd0,
	0xd0,
	0x82,
	0xd0,
	0x83,
	0xd0,
	0xe0,
	0x32,
	0xe5,
	0x4f,
	0xd3,
	0x94,
	0x40,
	0x40,
	0x04,
	0x7f,
	0x40,
	0x80,
	0x02,
	0xaf,
	0x4f,
	0x8f,
	0x4f,
	0x90,
	0x0e,
	0x86,
	0xe4,
	0x93,
	0xfe,
	0x74,
	0x01,
};
static kal_uint8 addr_data_pair20[255] = {
	0x92,
	0xc6,
	0x93,
	0xff,
	0xc3,
	0x90,
	0x0e,
	0x84,
	0x74,
	0x01,
	0x93,
	0x9f,
	0xff,
	0xe4,
	0x93,
	0x9e,
	0xfe,
	0xe4,
	0x8f,
	0x12,
	0x8e,
	0x11,
	0xf5,
	0x10,
	0xf5,
	0x0f,
	0xab,
	0x12,
	0xaa,
	0x11,
	0xa9,
	0x10,
	0xa8,
	0x0f,
	0xaf,
	0x4f,
	0xfc,
	0xfd,
	0xfe,
	0x12,
	0x0a,
	0xf0,
	0x12,
	0x14,
	0xfd,
	0xe4,
	0x7b,
	0x40,
	0xfa,
	0xf9,
	0xf8,
	0x12,
	0x0b,
	0x7b,
	0x12,
	0x14,
	0xfd,
	0x90,
	0x0e,
	0x71,
	0xe4,
	0x12,
	0x15,
	0x12,
	0x12,
	0x14,
	0xfd,
	0xe4,
	0x85,
	0x4e,
	0x0e,
	0xf5,
	0x0d,
	0xf5,
	0x0c,
	0xf5,
	0x0b,
	0xaf,
	0x0e,
	0xae,
	0x0d,
	0xad,
	0x0c,
	0xac,
	0x0b,
	0xa3,
	0x12,
	0x15,
	0x12,
	0x8f,
	0x0e,
	0x8e,
	0x0d,
	0x8d,
	0x0c,
	0x8c,
	0x0b,
	0xe5,
	0x12,
	0x45,
	0x0e,
	0xf5,
	0x12,
	0xe5,
	0x11,
	0x45,
	0x0d,
	0xf5,
	0x11,
	0xe5,
	0x10,
	0x45,
	0x0c,
	0xf5,
	0x10,
	0xe5,
	0x0f,
	0x45,
	0x0b,
	0xf5,
	0x0f,
	0xe4,
	0xf5,
	0x22,
	0xf5,
	0x23,
	0x85,
	0x12,
	0x40,
	0x85,
	0x11,
	0x3f,
	0x85,
	0x10,
	0x3e,
	0x85,
	0x0f,
	0x3d,
	0x02,
	0x14,
	0xaf,
	0x75,
	0x89,
	0x03,
	0x75,
	0xa8,
	0x01,
	0x75,
	0xb8,
	0x04,
	0x75,
	0x0a,
	0xff,
	0x75,
	0x0b,
	0x0e,
	0x75,
	0x0c,
	0x15,
	0x75,
	0x0d,
	0x0f,
	0x12,
	0x14,
	0x36,
	0x12,
	0x08,
	0x60,
	0xc2,
	0x39,
	0x12,
	0x00,
	0x06,
	0xd2,
	0x00,
	0xd2,
	0x35,
	0xd2,
	0xaf,
	0x75,
	0x0a,
	0xff,
	0x75,
	0x0b,
	0x0e,
	0x75,
	0x0c,
	0x51,
	0x75,
	0x0d,
	0x03,
	0x12,
	0x14,
	0x36,
	0x30,
	0x08,
	0x09,
	0xc2,
	0x35,
	0x12,
	0x0f,
	0xa7,
	0xc2,
	0x08,
	0xd2,
	0x35,
	0x30,
	0x0b,
	0x09,
	0xc2,
	0x37,
	0x12,
	0x04,
	0xa8,
	0xc2,
	0x0b,
	0xd2,
	0x37,
	0x30,
	0x09,
	0x09,
	0xc2,
	0x37,
	0x12,
	0x00,
	0x0e,
	0xc2,
	0x09,
	0xd2,
	0x37,
	0x30,
	0x0e,
	0x03,
	0x12,
	0x08,
	0x60,
	0x30,
	0x36,
	0xd3,
	0x90,
	0x30,
	0x29,
	0xe5,
	0x1d,
	0xf0,
	0xb4,
	0x10,
	0x05,
	0x90,
	0x30,
	0x23,
	0xe4,
	0xf0,
	0xc2,
	0x36,
};
static kal_uint8 addr_data_pair21[255] = {
	0x93,
	0xc3,
	0x80,
	0xc1,
	0xe4,
	0xf5,
	0x4f,
	0x90,
	0x0e,
	0x82,
	0x93,
	0xff,
	0xe4,
	0x8f,
	0x0d,
	0xf5,
	0x0c,
	0xf5,
	0x0b,
	0xf5,
	0x0a,
	0xaf,
	0x0d,
	0xae,
	0x0c,
	0xad,
	0x0b,
	0xac,
	0x0a,
	0x90,
	0x0e,
	0x72,
	0x12,
	0x15,
	0x12,
	0x8f,
	0x0d,
	0x8e,
	0x0c,
	0x8d,
	0x0b,
	0x8c,
	0x0a,
	0x90,
	0x0e,
	0x7a,
	0x12,
	0x0c,
	0x44,
	0xef,
	0x45,
	0x0d,
	0xf5,
	0x0d,
	0xee,
	0x45,
	0x0c,
	0xf5,
	0x0c,
	0xed,
	0x45,
	0x0b,
	0xf5,
	0x0b,
	0xec,
	0x45,
	0x0a,
	0xf5,
	0x0a,
	0xe4,
	0xf5,
	0x22,
	0xf5,
	0x23,
	0x85,
	0x0d,
	0x40,
	0x85,
	0x0c,
	0x3f,
	0x85,
	0x0b,
	0x3e,
	0x85,
	0x0a,
	0x3d,
	0x12,
	0x14,
	0xaf,
	0xe4,
	0xf5,
	0x22,
	0xf5,
	0x23,
	0x90,
	0x0e,
	0x7a,
	0x12,
	0x15,
	0x06,
	0x12,
	0x14,
	0xaf,
	0xe4,
	0xf5,
	0x22,
	0xf5,
	0x23,
	0x90,
	0x0e,
	0x76,
	0x12,
	0x15,
	0x06,
	0x02,
	0x14,
	0xaf,
	0xae,
	0x0b,
	0xaf,
	0x0c,
	0xe4,
	0xfd,
	0xed,
	0xc3,
	0x95,
	0x0d,
	0x50,
	0x33,
	0x12,
	0x15,
	0x68,
	0xe4,
	0x93,
	0xf5,
	0x0e,
	0x74,
	0x01,
	0x93,
	0xf5,
	0x0f,
	0x45,
	0x0e,
	0x60,
	0x23,
	0x85,
	0x0f,
	0x82,
	0x85,
	0x0e,
	0x83,
	0xe0,
	0xfc,
	0x12,
	0x15,
	0x68,
	0x74,
	0x03,
	0x93,
	0x52,
	0x04,
	0x12,
	0x15,
	0x68,
	0x74,
	0x02,
	0x93,
	0x42,
	0x04,
	0x85,
	0x0f,
	0x82,
	0x85,
	0x0e,
	0x83,
	0xec,
	0xf0,
	0x0d,
	0x80,
	0xc7,
	0x22,
	0x7e,
	0x00,
	0xad,
	0x03,
	0xac,
	0x02,
	0x12,
	0x0a,
	0x89,
	0x8e,
	0x0e,
	0x8f,
	0x0f,
	0x22,
	0x12,
	0x0a,
	0x89,
	0x8e,
	0x10,
	0x8f,
	0x11,
	0x90,
	0x0e,
	0x88,
	0xe4,
	0x93,
	0x22,
	0xc3,
	0xe5,
	0x0d,
	0x9f,
	0xf5,
	0x0d,
	0xe5,
	0x0c,
	0x9e,
	0xf5,
	0x0c,
	0x22,
	0xae,
	0xf0,
	0xfb,
	0xee,
	0x34,
	0x60,
	0x8b,
	0x82,
	0xf5,
	0x83,
	0x22,
	0xe0,
	0xfe,
	0xa3,
	0xe0,
	0xfd,
	0xed,
	0x22,
	0xa2,
	0xaf,
	0x92,
	0x33,
	0xc2,
	0xaf,
	0xe5,
	0x23,
	0x45,
	0x22,
	0x90,
	0x0e,
	0x65,
	0x60,
	0x0e,
	0x12,
	0x15,
};
static kal_uint8 addr_data_pair22[181] = {
	0x94,
	0xc0,
	0x43,
	0xe0,
	0xf5,
	0x3b,
	0x12,
	0x15,
	0x40,
	0xe0,
	0xf5,
	0x3c,
	0x80,
	0x0c,
	0x12,
	0x15,
	0x43,
	0xe5,
	0x3f,
	0xf0,
	0x12,
	0x15,
	0x40,
	0xe5,
	0x40,
	0xf0,
	0xa2,
	0x33,
	0x92,
	0xaf,
	0x22,
	0x78,
	0xcc,
	0x12,
	0x0e,
	0xf7,
	0x40,
	0x0d,
	0x12,
	0x0e,
	0xf5,
	0x40,
	0x04,
	0xe4,
	0xff,
	0x80,
	0x0f,
	0x7f,
	0x01,
	0x80,
	0x0b,
	0x12,
	0x0e,
	0xf5,
	0x40,
	0x04,
	0x7f,
	0xff,
	0x80,
	0x02,
	0x7f,
	0xfe,
	0x22,
	0x8f,
	0x12,
	0x8e,
	0x11,
	0x8d,
	0x10,
	0x8c,
	0x0f,
	0x22,
	0x12,
	0x0c,
	0x44,
	0x8f,
	0x40,
	0x8e,
	0x3f,
	0x8d,
	0x3e,
	0x8c,
	0x3d,
	0x22,
	0x93,
	0xf9,
	0xf8,
	0x02,
	0x0c,
	0x31,
	0xc0,
	0xe0,
	0xc0,
	0x83,
	0xc0,
	0x82,
	0x90,
	0x3f,
	0x0d,
	0xe0,
	0xf5,
	0x09,
	0xe5,
	0x09,
	0xf0,
	0xd0,
	0x82,
	0xd0,
	0x83,
	0xd0,
	0xe0,
	0x32,
	0xc3,
	0xee,
	0x64,
	0x80,
	0x94,
	0x80,
	0x40,
	0x02,
	0x80,
	0x07,
	0xc3,
	0xe4,
	0x9f,
	0xff,
	0xe4,
	0x9e,
	0xfe,
	0x22,
	0x90,
	0x0e,
	0x67,
	0xe4,
	0x93,
	0xfe,
	0x74,
	0x01,
	0x93,
	0xf5,
	0x82,
	0x8e,
	0x83,
	0x22,
	0xd2,
	0x01,
	0xc2,
	0x02,
	0xe4,
	0xf5,
	0x1e,
	0xf5,
	0x1d,
	0xd2,
	0x36,
	0xd2,
	0x34,
	0x22,
	0x78,
	0x7f,
	0xe4,
	0xf6,
	0xd8,
	0xfd,
	0x75,
	0x81,
	0xd1,
	0x02,
	0x13,
	0x51,
	0x8f,
	0x82,
	0x8e,
	0x83,
	0x75,
	0xf0,
	0x04,
	0xed,
	0x02,
	0x0c,
	0x54,
};
/* ===================For iBurstWriteReg AF regs end======================== */

static kal_uint16 read_cmos_sensor(kal_uint32 addr)
{
	kal_uint16 get_byte = 0;
	char pu_send_cmd[2] = {(char)(addr >> 8), (char)(addr & 0xFF) };

	 /* Add this func to set i2c speed by each sensor */
	kdSetI2CSpeed(imgsensor_info.i2c_speed);
	iReadRegI2C(pu_send_cmd, 2, (u8 *)&get_byte, 1, imgsensor.i2c_write_id);
	return get_byte;
}

static void write_cmos_sensor(kal_uint32 addr, kal_uint32 para)
{
	char pu_send_cmd[3] = {(char)(addr >> 8),
		(char)(addr & 0xFF), (char)(para & 0xFF)};

	/* Add this func to set i2c speed by each sensor */
	kdSetI2CSpeed(imgsensor_info.i2c_speed);
	iWriteRegI2C(pu_send_cmd, 3, imgsensor.i2c_write_id);
}

static void get_exifInfo(uintptr_t exifAddr)
{
	struct SENSOR_EXIF_INFO_STRUCT *pExifInfo =
		(struct SENSOR_EXIF_INFO_STRUCT *)exifAddr;

	LOG_INF("E\n");
	pExifInfo->FNumber = imgsensor.FNumber;
	pExifInfo->AEISOSpeed = imgsensor.iso_speed;
	pExifInfo->AWBMode = imgsensor.awb_mode;
	pExifInfo->CapExposureTime = imgsensor.scene_mode;
	pExifInfo->FlashLightTimeus = 0;
	pExifInfo->RealISOValue = imgsensor.iso_speed;
	LOG_INF("Exit\n");
}
static void write_shutter(kal_uint32 shutter)
{
	/*kal_uint16 realtime_fps = 0;*/
	/*kal_uint32 frame_length = 0;*/
	unsigned long flags;

	spin_lock_irqsave(&imgsensor_drv_lock, flags);
	imgsensor.shutter = shutter;
	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);

	spin_lock_irqsave(&imgsensor_drv_lock, flags);
	if (shutter > imgsensor.min_frame_length - imgsensor_info.margin)
		imgsensor.frame_length = shutter + imgsensor_info.margin;
	else
		imgsensor.frame_length = imgsensor.min_frame_length;
	if (imgsensor.frame_length > imgsensor_info.max_frame_length)
		imgsensor.frame_length = imgsensor_info.max_frame_length;
	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
	shutter = (shutter < imgsensor_info.min_shutter) ?
		imgsensor_info.min_shutter : shutter;
	shutter = (shutter >
		(imgsensor_info.max_frame_length - imgsensor_info.margin)) ?
		(imgsensor_info.max_frame_length - imgsensor_info.margin) :
		shutter;
	write_cmos_sensor(0x380F, (imgsensor.frame_length&0xFF));
	write_cmos_sensor(0x380E, ((imgsensor.frame_length&0xFF00) >> 8));
	write_cmos_sensor(0x350D, 0x00);
	write_cmos_sensor(0x350C, 0x00);

	shutter *= 16;
	write_cmos_sensor(0x3502, (shutter & 0x00FF)); /* AEC[7:0] */
	write_cmos_sensor(0x3501, ((shutter & 0x0FF00) >> 8)); /* AEC[15:8] */
	write_cmos_sensor(0x3500, ((shutter & 0xFF0000) >> 16));
	LOG_INF("Exit! shutter =%d, framelength =%d\n",
	shutter, imgsensor.frame_length);
}
/*************************************************************************
 * FUNCTION
 *	set_shutter
 *
 * DESCRIPTION
 *	This function set e-shutter of sensor to change exposure time.
 *
 * PARAMETERS
 *	iShutter : exposured lines
 *
 * RETURNS
 *	None
 *
 * GLOBALS AFFECTED
 *
 *************************************************************************/
static void set_shutter(kal_uint16 shutter)
{
	unsigned long flags;

	LOG_INF("shutter:%d\n", shutter);
	spin_lock_irqsave(&imgsensor_drv_lock, flags);
	imgsensor.shutter = shutter;
	spin_unlock_irqrestore(&imgsensor_drv_lock, flags);
	write_shutter(shutter);
} /* set_shutter */
static kal_uint32 get_shutter(void)
{
	unsigned int interval1, interval2, interval3, shutter_value;

	interval1 = read_cmos_sensor(0x3500); /* AEC[b19~b16] */
	interval2 = read_cmos_sensor(0x3501); /* AEC[b15~b8] */
	interval3 = read_cmos_sensor(0x3502); /* AEC[b7~b0] */
	shutter_value  = (interval1 << 12) |
			 (interval2 << 4) |
			 (interval3 >> 4);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.shutter = shutter_value;
	spin_unlock(&imgsensor_drv_lock);
	LOG_INF("Exit! shutter =%d\n", shutter_value);
	return shutter_value;
}
static kal_uint16 set_gain(kal_uint16 gain)
{
	kal_uint16 interval = 0;

	LOG_INF("E:gain=%d\n", gain);
	if (gain > 1024)
		ASSERT(0);
	interval = gain&0x0FF;
	write_cmos_sensor(0x350B, interval);
	return gain;
}
static kal_uint32 get_gain(void)
{
	unsigned int interval = 0;

	interval = read_cmos_sensor(0x350B&0xFF);
	LOG_INF("Exit! gain =%d\n", interval);
	return interval;
}

#if 0
static void set_mirror_flip(kal_uint8 image_mirror)
{
	kal_uint8 mirror = 0, flip = 0;

	LOG_INF("image_mirror = %d", image_mirror);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.mirror = image_mirror;
	spin_unlock(&imgsensor_drv_lock);
	flip  = read_cmos_sensor(0x3820);
	mirror = read_cmos_sensor(0x3821);
	if (imgsensor.sensor_mode == IMGSENSOR_MODE_CAPTURE) {
		switch (image_mirror) {
		case IMAGE_NORMAL:
			write_cmos_sensor(0x3820, flip&0xf9);
			write_cmos_sensor(0x3821, mirror&0xf9);
			write_cmos_sensor(0x4514, 0x00);
			break;
		case IMAGE_H_MIRROR:
			write_cmos_sensor(0x3820, flip&0xf9);
			write_cmos_sensor(0x3821, mirror|0x06);
			write_cmos_sensor(0x4514, 0x00);
			break;
		case IMAGE_V_MIRROR:
			write_cmos_sensor(0x3820, flip|0x06);
			write_cmos_sensor(0x3821, mirror&0xf9);
			write_cmos_sensor(0x4514, 0xaa);
			break;
		case IMAGE_HV_MIRROR:
			write_cmos_sensor(0x3820, flip|0x06);
			write_cmos_sensor(0x3821, mirror|0x06);
			write_cmos_sensor(0x4514, 0xbb);
			break;
		default:
			LOG_INF("Error image_mirror setting\n");
		}
	} else {
		switch (image_mirror) {
		case IMAGE_NORMAL:
			write_cmos_sensor(0x3820, flip&0xf9);
			write_cmos_sensor(0x3821, mirror&0xf9);
			write_cmos_sensor(0x4514, 0x00);
			break;
		case IMAGE_H_MIRROR:
			write_cmos_sensor(0x3820, flip&0xf9);
			write_cmos_sensor(0x3821, mirror|0x06);
			write_cmos_sensor(0x4514, 0x00);
			break;
		case IMAGE_V_MIRROR:
			write_cmos_sensor(0x3820, flip|0x06);
			write_cmos_sensor(0x3821, mirror&0xf9);
			write_cmos_sensor(0x4514, 0x00);
			break;
		case IMAGE_HV_MIRROR:
			write_cmos_sensor(0x3820, flip|0x06);
			write_cmos_sensor(0x3821, mirror|0x06);
			write_cmos_sensor(0x4514, 0x00);
			break;
		default:
			LOG_INF("Error image_mirror setting\n");
		}
	}
}
#endif

static void set_ae_lock(void)
{
	kal_uint8 interval;

	LOG_INF("E\n");
	interval = read_cmos_sensor(0x3503);
	write_cmos_sensor(0x3503, (interval|0x07));
	spin_lock(&imgsensor_drv_lock);
	imgsensor.awbaelock = TRUE;
	spin_unlock(&imgsensor_drv_lock);
}
static void set_ae_unlock(void)
{
	kal_uint8 interval;

	LOG_INF("E\n");
	interval = read_cmos_sensor(0x3503);
	write_cmos_sensor(0x3503, (interval&(~0x07)));
	spin_lock(&imgsensor_drv_lock);
	imgsensor.awbaelock = TRUE;
	spin_unlock(&imgsensor_drv_lock);
}
static void set_awb_lock(void)
{
	kal_uint8 interval;

	LOG_INF("E\n");
	interval = read_cmos_sensor(0x3406);
	write_cmos_sensor(0x3406, interval|0x01);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.awbaelock = TRUE;
	spin_unlock(&imgsensor_drv_lock);
}
static void set_awb_unlock(void)
{
	kal_uint8 interval;

	LOG_INF("E\n");
	interval = read_cmos_sensor(0x3406);
	write_cmos_sensor(0x3406, interval&0xFE);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.awbaelock = FALSE;
	spin_unlock(&imgsensor_drv_lock);
}
void set_3actrl_info(enum ACDK_SENSOR_3A_LOCK_ENUM action)
{
	LOG_INF("E action =%d\n", action);
	switch (action) {
	case SENSOR_3A_AE_LOCK:
		set_ae_lock();
		break;
	case SENSOR_3A_AE_UNLOCK:
		set_ae_unlock();
		break;
	case SENSOR_3A_AWB_LOCK:
		set_awb_lock();
		break;
	case SENSOR_3A_AWB_UNLOCK:
		set_awb_unlock();
		if (!((imgsensor.scene_mode == SCENE_MODE_OFF)
			|| (imgsensor.scene_mode == SCENE_MODE_NORMAL)
			|| (imgsensor.scene_mode == SCENE_MODE_HDR))) {
			set_scene_mode(imgsensor.scene_mode);
			LOG_INF("E imgsensor.scene_mode =%d\n",
				imgsensor.scene_mode);
		}
		if (!((imgsensor.awb_mode == AWB_MODE_OFF) ||
			(imgsensor.awb_mode == AWB_MODE_AUTO))) {
			LOG_INF("E imgsensor.awb_mode =%d\n",
				imgsensor.awb_mode);
			set_param_wb(imgsensor.awb_mode);
		}
		break;
	default:
		break;
	}
}
static BOOL set_param_wb(UINT16 para)
{
	LOG_INF("E imgsensor.awb_mode = %d\n", para);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.awb_mode = para;
	spin_unlock(&imgsensor_drv_lock);
	switch (para) {
	case AWB_MODE_AUTO:
		set_awb_unlock();
		break;
	case AWB_MODE_OFF:
		set_awb_lock();
		break;
	case AWB_MODE_CLOUDY_DAYLIGHT:
		write_cmos_sensor(0x3212, 0x03);
		set_awb_unlock();
		write_cmos_sensor(0x3400, 0x06);
		write_cmos_sensor(0x3401, 0x30);
		write_cmos_sensor(0x3402, 0x04);
		write_cmos_sensor(0x3403, 0x00);
		write_cmos_sensor(0x3404, 0x04);
		write_cmos_sensor(0x3405, 0x30);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case AWB_MODE_DAYLIGHT:
		write_cmos_sensor(0x3212, 0x03);
		set_awb_unlock();
		write_cmos_sensor(0x3400, 0x06);
		write_cmos_sensor(0x3401, 0x10);
		write_cmos_sensor(0x3402, 0x04);
		write_cmos_sensor(0x3403, 0x00);
		write_cmos_sensor(0x3404, 0x04);
		write_cmos_sensor(0x3405, 0x48);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case AWB_MODE_INCANDESCENT:
		write_cmos_sensor(0x3212, 0x03);
		set_awb_unlock();
		write_cmos_sensor(0x3400, 0x04);
		write_cmos_sensor(0x3401, 0xe0);
		write_cmos_sensor(0x3402, 0x04);
		write_cmos_sensor(0x3403, 0x00);
		write_cmos_sensor(0x3404, 0x05);
		write_cmos_sensor(0x3405, 0xa0);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case AWB_MODE_FLUORESCENT:
		write_cmos_sensor(0x3212, 0x03);
		set_awb_unlock();
		write_cmos_sensor(0x3400, 0x04);
		write_cmos_sensor(0x3401, 0x00);
		write_cmos_sensor(0x3402, 0x04);
		write_cmos_sensor(0x3403, 0x00);
		write_cmos_sensor(0x3404, 0x06);
		write_cmos_sensor(0x3405, 0x50);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case AWB_MODE_TUNGSTEN:
		write_cmos_sensor(0x3212, 0x03);
		set_awb_unlock();
		write_cmos_sensor(0x3400, 0x05);
		write_cmos_sensor(0x3401, 0x48);
		write_cmos_sensor(0x3402, 0x04);
		write_cmos_sensor(0x3403, 0x00);
		write_cmos_sensor(0x3404, 0x05);
		write_cmos_sensor(0x3405, 0xe0);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	default:
		break; /*return FALSE;*/
	}
	return TRUE;
}
static void set_contrast(UINT16 para)
{
	LOG_INF("E para= %d\n", para);
	switch (para) {
	case ISP_CONTRAST_LOW:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5586, 0x14);
		write_cmos_sensor(0x5585, 0x14);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case ISP_CONTRAST_HIGH:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5586, 0x2c);
		write_cmos_sensor(0x5585, 0x1c);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case ISP_CONTRAST_MIDDLE:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5586, 0x20);
		write_cmos_sensor(0x5585, 0x00);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	default:
		break;
	}

}
static void set_brightness(UINT16 para)
{
	LOG_INF("E set_contrast = %d\n", para);
	switch (para) {
	case ISP_BRIGHT_LOW:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5587, 0x40);
		write_cmos_sensor(0x5588, 0x09);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case ISP_BRIGHT_HIGH:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5587, 0x40);
		write_cmos_sensor(0x5588, 0x01);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case ISP_BRIGHT_MIDDLE:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5587, 0x00);
		write_cmos_sensor(0x5588, 0x01);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	default:
		LOG_INF("FAIL:no case match\n");
		/*return KAL_FALSE;*/
		break;
	}

}

static void set_saturation(UINT16 para)
{
	LOG_INF("E set_contrast = %d\n", para);
	switch (para) {
	case ISP_SAT_HIGH:
		write_cmos_sensor(0x3212, 0x01);
		write_cmos_sensor(0x5384, 0x0a);
		write_cmos_sensor(0x5385, 0x8C);
		write_cmos_sensor(0x5386, 0x96);
		write_cmos_sensor(0x5387, 0x9B);
		write_cmos_sensor(0x5388, 0x8B);
		write_cmos_sensor(0x5389, 0x10);
		write_cmos_sensor(0x3212, 0x11);
		write_cmos_sensor(0x3212, 0xa1);
		break;
	case ISP_SAT_LOW:
		write_cmos_sensor(0x3212, 0x01);
		write_cmos_sensor(0x5384, 0x06);
		write_cmos_sensor(0x5385, 0x5E);
		write_cmos_sensor(0x5386, 0x64);
		write_cmos_sensor(0x5387, 0x67);
		write_cmos_sensor(0x5388, 0x5D);
		write_cmos_sensor(0x5389, 0x0A);
		write_cmos_sensor(0x3212, 0x11);
		write_cmos_sensor(0x3212, 0xa1);
		break;
	case ISP_SAT_MIDDLE:
		write_cmos_sensor(0x3212, 0x01);
		write_cmos_sensor(0x5384, 0x08);
		write_cmos_sensor(0x5385, 0x75);
		write_cmos_sensor(0x5386, 0x7D);
		write_cmos_sensor(0x5387, 0x81);
		write_cmos_sensor(0x5388, 0x74);
		write_cmos_sensor(0x5389, 0x0D);
		write_cmos_sensor(0x3212, 0x11);
		write_cmos_sensor(0x3212, 0xa1);
		break;
	default:
		break;
	}
	mDELAY(50);

}

static UINT32 set_max_framerate(UINT16 u2FrameRate)
{
	LOG_INF("E u2FrameRate = %d\n", u2FrameRate);
#if 0
	if (u2FrameRate == 30) {
		/* OV5645MIPI 1280x960,30fps */
		/* 56Mhz, 224Mbps/Lane, 2Lane */
		write_cmos_sensor(0x3A00, 0x38); /* fix30 */
		write_cmos_sensor(0x300e, 0x45); /* MIPI 2 lane */
		write_cmos_sensor(0x3034, 0x18); /* PLL, MIPI 8-bit mode */
		write_cmos_sensor(0x3035, 0x21); /* PLL */
		write_cmos_sensor(0x3036, 0x70); /* PLL */
		write_cmos_sensor(0x3037, 0x13); /* PLL */
		write_cmos_sensor(0x3108, 0x01); /* PLL */
		write_cmos_sensor(0x3824, 0x01); /* PLL */
		write_cmos_sensor(0x460c, 0x20); /* PLL */
		write_cmos_sensor(0x3618, 0x00);
		write_cmos_sensor(0x3600, 0x09);
		write_cmos_sensor(0x3601, 0x43);
		write_cmos_sensor(0x3708, 0x66);
		write_cmos_sensor(0x3709, 0x12);
		write_cmos_sensor(0x370c, 0xc3);
		write_cmos_sensor(0x3800, 0x00); /* HS = 0 */
		write_cmos_sensor(0x3801, 0x00); /* HS */
		write_cmos_sensor(0x3802, 0x00); /* VS = 250 */
		write_cmos_sensor(0x3803, 0x06); /* VS */
		write_cmos_sensor(0x3804, 0x0a); /* HW = 2623 */
		write_cmos_sensor(0x3805, 0x3f); /* HW */
		write_cmos_sensor(0x3806, 0x07); /* VH */
		write_cmos_sensor(0x3807, 0x9d); /* VH */
		write_cmos_sensor(0x3808, 0x05); /* DVPHO = 1280 */
		write_cmos_sensor(0x3809, 0x00); /* DVPHO */
		write_cmos_sensor(0x380a, 0x03); /* DVPVO = 960 */
		write_cmos_sensor(0x380b, 0xc0); /* DVPVO */
		write_cmos_sensor(0x380c, 0x07); /* HTS = 2160 */
		write_cmos_sensor(0x380d, 0x68); /* HTS */
		write_cmos_sensor(0x380e, 0x03); /* VTS = 740 */
		write_cmos_sensor(0x380f, 0xd8); /* VTS */
		write_cmos_sensor(0x3810, 0x00); /* H OFF = 16 */
		write_cmos_sensor(0x3811, 0x10); /* H OFF */
		write_cmos_sensor(0x3812, 0x00); /* V OFF = 4 */
		write_cmos_sensor(0x3813, 0x06); /* V OFF */
		write_cmos_sensor(0x3814, 0x31); /* X INC */
		write_cmos_sensor(0x3815, 0x31); /* Y INC */
		write_cmos_sensor(0x3820, 0x41); /* flip off, V bin on */
		write_cmos_sensor(0x3821, 0x01); /* mirror on, H bin on */
		write_cmos_sensor(0x4514, 0x00);
		write_cmos_sensor(0x3a00, 0x38); /* ae mode */
		write_cmos_sensor(0x3a02, 0x03); /* max exp 60 = 740 */
		write_cmos_sensor(0x3a03, 0xd8); /* max exp 60 */
		write_cmos_sensor(0x3a08, 0x01); /* B50 = 222 */
		write_cmos_sensor(0x3a09, 0x27); /* B50 */
		write_cmos_sensor(0x3a0a, 0x00); /* B60 = 185 */
		write_cmos_sensor(0x3a0b, 0xf6); /* B60 */
		write_cmos_sensor(0x3a0e, 0x03); /* max 50 */
		write_cmos_sensor(0x3a0d, 0x04); /* max 60 */
		write_cmos_sensor(0x3a14, 0x03); /* max exp 50 = 740 */
		write_cmos_sensor(0x3a15, 0xd8); /* max exp 50 */
		write_cmos_sensor(0x3c07, 0x07); /* 50/60 auto detect */
		write_cmos_sensor(0x3c08, 0x01); /* 50/60 auto detect */
		write_cmos_sensor(0x3c09, 0xc2); /* 50/60 auto detect */
		write_cmos_sensor(0x4004, 0x02); /* BLC line number */

		/* BLC triggered by gain change */
		write_cmos_sensor(0x4005, 0x18);

		write_cmos_sensor(0x4837, 0x11); /* MIPI global timing 16 */
		write_cmos_sensor(0x503d, 0x00);
		write_cmos_sensor(0x5000, 0xa7);
		write_cmos_sensor(0x5001, 0xa3);
		write_cmos_sensor(0x5002, 0x80);
		write_cmos_sensor(0x5003, 0x08);
		write_cmos_sensor(0x3032, 0x00);
		write_cmos_sensor(0x4000, 0x89);
		write_cmos_sensor(0x350c, 0x00);
		write_cmos_sensor(0x350d, 0x00);
		}
	else if (u2FrameRate == 15) {
		/* OV5645MIPI 1280x960,15fps */
		/* 28Mhz, 112Mbps/Lane, 2Lane */
		write_cmos_sensor(0x3A00, 0x38); /* fix15 */
		write_cmos_sensor(0x300e, 0x45); /* MIPI 2 lane */
		write_cmos_sensor(0x3034, 0x18); /* PLL, MIPI 8-bit mode */
		write_cmos_sensor(0x3035, 0x21); /* PLL */
		write_cmos_sensor(0x3036, 0x38); /* PLL */
		write_cmos_sensor(0x3037, 0x13); /* PLL */
		write_cmos_sensor(0x3108, 0x01); /* PLL */
		write_cmos_sensor(0x3824, 0x01); /* PLL */
		write_cmos_sensor(0x460c, 0x20); /* PLL */
		write_cmos_sensor(0x3618, 0x00);
		write_cmos_sensor(0x3600, 0x09);
		write_cmos_sensor(0x3601, 0x43);
		write_cmos_sensor(0x3708, 0x66);
		write_cmos_sensor(0x3709, 0x12);
		write_cmos_sensor(0x370c, 0xc3);
		write_cmos_sensor(0x3800, 0x00); /* HS = 0 */
		write_cmos_sensor(0x3801, 0x00); /* HS */
		write_cmos_sensor(0x3802, 0x00); /* VS = 250 */
		write_cmos_sensor(0x3803, 0x06); /* VS */
		write_cmos_sensor(0x3804, 0x0a); /* HW = 2623 */
		write_cmos_sensor(0x3805, 0x3f); /* HW */
		write_cmos_sensor(0x3806, 0x07); /* VH */
		write_cmos_sensor(0x3807, 0x9d); /* VH */
		write_cmos_sensor(0x3808, 0x05); /* DVPHO = 1280 */
		write_cmos_sensor(0x3809, 0x00); /* DVPHO */
		write_cmos_sensor(0x380a, 0x03); /* DVPVO = 960 */
		write_cmos_sensor(0x380b, 0xc0); /* DVPVO */
		write_cmos_sensor(0x380c, 0x07); /* HTS = 2160 */
		write_cmos_sensor(0x380d, 0x68); /* HTS */
		write_cmos_sensor(0x380e, 0x03); /* VTS = 740 */
		write_cmos_sensor(0x380f, 0xd8); /* VTS */
		write_cmos_sensor(0x3810, 0x00); /* H OFF = 16 */
		write_cmos_sensor(0x3811, 0x10); /* H OFF */
		write_cmos_sensor(0x3812, 0x00); /* V OFF = 4 */
		write_cmos_sensor(0x3813, 0x06); /* V OFF */
		write_cmos_sensor(0x3814, 0x31); /* X INC */
		write_cmos_sensor(0x3815, 0x31); /* Y INC */
		write_cmos_sensor(0x3820, 0x41); /* flip off, V bin on */
		write_cmos_sensor(0x3821, 0x01); /* mirror on, H bin on */
		write_cmos_sensor(0x4514, 0x00);
		write_cmos_sensor(0x3a00, 0x38); /* ae mode */
		write_cmos_sensor(0x3a02, 0x03); /* max exp 60 = 740 */
		write_cmos_sensor(0x3a03, 0xd8); /* max exp 60 */
		write_cmos_sensor(0x3a08, 0x00); /* B50 = 222 */
		write_cmos_sensor(0x3a09, 0x94); /* B50 */
		write_cmos_sensor(0x3a0a, 0x00); /* B60 = 185 */
		write_cmos_sensor(0x3a0b, 0x7b); /* B60 */
		write_cmos_sensor(0x3a0e, 0x06); /* max 50 */
		write_cmos_sensor(0x3a0d, 0x07); /* max 60 */
		write_cmos_sensor(0x3a14, 0x03); /* max exp 50 = 740 */
		write_cmos_sensor(0x3a15, 0xd8); /* max exp 50 */
		write_cmos_sensor(0x3c07, 0x08); /* 50/60 auto detect */
		write_cmos_sensor(0x3c08, 0x00); /* 50/60 auto detect */
		write_cmos_sensor(0x3c09, 0x1c); /* 50/60 auto detect */
		write_cmos_sensor(0x4004, 0x02); /* BLC line number */

		/* BLC triggered by gain change */
		write_cmos_sensor(0x4005, 0x18);

		write_cmos_sensor(0x4837, 0x11); /* MIPI global timing 16 */
		write_cmos_sensor(0x503d, 0x00);
		write_cmos_sensor(0x5000, 0xa7);
		write_cmos_sensor(0x5001, 0xa3);
		write_cmos_sensor(0x5002, 0x80);
		write_cmos_sensor(0x5003, 0x08);
		write_cmos_sensor(0x3032, 0x00);
		write_cmos_sensor(0x4000, 0x89);
		write_cmos_sensor(0x350c, 0x00);
		write_cmos_sensor(0x350d, 0x00);
	} else
		LOG_INF("Wrong frame rate setting\n");
#endif
	return TRUE;
}
static void set_scenemode_portrait(void)
{
	LOG_INF("E\n");
	write_cmos_sensor(0x3212, 0x03);
	write_cmos_sensor(0x3A00, 0x3c); /* 10-30 */
	write_cmos_sensor(0x3a02, 0x0b);
	write_cmos_sensor(0x3a03, 0x88);
	write_cmos_sensor(0x3a14, 0x0b);
	write_cmos_sensor(0x3a15, 0x88);
	/*CMX*/
	write_cmos_sensor(0x5381, 0x1e);
	write_cmos_sensor(0x5382, 0x5b);
	write_cmos_sensor(0x5383, 0x08);
	write_cmos_sensor(0x5384, 0x0a);
	write_cmos_sensor(0x5385, 0x7e);
	write_cmos_sensor(0x5386, 0x88);
	write_cmos_sensor(0x5387, 0x7c);
	write_cmos_sensor(0x5388, 0x6c);
	write_cmos_sensor(0x5389, 0x10);
	write_cmos_sensor(0x538a, 0x01);
	write_cmos_sensor(0x538b, 0x98);
	/*AE Weight - Average*/
	write_cmos_sensor(0x501d, 0x00);
	write_cmos_sensor(0x5688, 0x11);
	write_cmos_sensor(0x5689, 0x11);
	write_cmos_sensor(0x568a, 0x14);
	write_cmos_sensor(0x568b, 0x41);
	write_cmos_sensor(0x568c, 0x14);
	write_cmos_sensor(0x568d, 0x41);
	write_cmos_sensor(0x568e, 0x11);
	write_cmos_sensor(0x568f, 0x11);
	/*FRAME rate*/
	write_cmos_sensor(0x3212, 0x13);
	write_cmos_sensor(0x3212, 0xa3);
}

static void set_scenemode_landscape(void)
{
	LOG_INF("E\n");
	write_cmos_sensor(0x3212, 0x03);
	write_cmos_sensor(0x3A00, 0x3c); /* 10-30 */
	write_cmos_sensor(0x3a02, 0x0b);
	write_cmos_sensor(0x3a03, 0x88);
	write_cmos_sensor(0x3a14, 0x0b);
	write_cmos_sensor(0x3a15, 0x88);
	/*CMX*/
	write_cmos_sensor(0x5381, 0x1c);
	write_cmos_sensor(0x5382, 0x5a);
	write_cmos_sensor(0x5383, 0x06);
	write_cmos_sensor(0x5384, 0x0d);
	write_cmos_sensor(0x5385, 0xa4);
	write_cmos_sensor(0x5386, 0xb1);
	write_cmos_sensor(0x5387, 0xa1);
	write_cmos_sensor(0x5388, 0x8c);
	write_cmos_sensor(0x5389, 0x15);
	write_cmos_sensor(0x538a, 0x01);
	write_cmos_sensor(0x538b, 0x98);

	/*AE Weight - Average*/
	write_cmos_sensor(0x501d, 0x00);
	write_cmos_sensor(0x5688, 0x11);
	write_cmos_sensor(0x5689, 0x11);
	write_cmos_sensor(0x568a, 0x11);
	write_cmos_sensor(0x568b, 0x11);
	write_cmos_sensor(0x568c, 0x11);
	write_cmos_sensor(0x568d, 0x11);
	write_cmos_sensor(0x568e, 0x11);
	write_cmos_sensor(0x568f, 0x11);
		/*FRAME rate*/
	write_cmos_sensor(0x3212, 0x13);
	write_cmos_sensor(0x3212, 0xa3);
}

static void set_scenemode_sunset(void)
{
	LOG_INF("E\n");
	write_cmos_sensor(0x3212, 0x03);
	write_cmos_sensor(0x3A00, 0x3c); /* 10-30 */
	write_cmos_sensor(0x3a02, 0x0b);
	write_cmos_sensor(0x3a03, 0x88);
	write_cmos_sensor(0x3a14, 0x0b);
	write_cmos_sensor(0x3a15, 0x88);
	/*CMX*/
	write_cmos_sensor(0x5381, 0x42);
	write_cmos_sensor(0x5382, 0x5a);
	write_cmos_sensor(0x5383, 0x08);
	write_cmos_sensor(0x5384, 0x20);
	write_cmos_sensor(0x5385, 0x7e);
	write_cmos_sensor(0x5386, 0x48);
	write_cmos_sensor(0x5387, 0xbc);
	write_cmos_sensor(0x5388, 0x6c);
	write_cmos_sensor(0x5389, 0x06);
	write_cmos_sensor(0x538a, 0x01);
	write_cmos_sensor(0x538b, 0x9c);
	/*AE Weight - Average*/
	write_cmos_sensor(0x501d, 0x00);
	write_cmos_sensor(0x5688, 0x11);
	write_cmos_sensor(0x5689, 0x11);
	write_cmos_sensor(0x568a, 0x14);
	write_cmos_sensor(0x568b, 0x41);
	write_cmos_sensor(0x568c, 0x14);
	write_cmos_sensor(0x568d, 0x41);
	write_cmos_sensor(0x568e, 0x11);
	write_cmos_sensor(0x568f, 0x11);
	/*FRAME rate*/
	write_cmos_sensor(0x3212, 0x13);
	write_cmos_sensor(0x3212, 0xa3);
}
static void set_scenemode_sports(void)
{
	LOG_INF("E\n");
	write_cmos_sensor(0x3212, 0x03);
	write_cmos_sensor(0x3A00, 0x38); /*10-30 */
	write_cmos_sensor(0x3a02, 0x03);
	write_cmos_sensor(0x3a03, 0xd8);
	write_cmos_sensor(0x3a14, 0x03);
	write_cmos_sensor(0x3a15, 0xd8);
	/*CMX*/
	write_cmos_sensor(0x5381, 0x21); /* CCM */
	write_cmos_sensor(0x5382, 0x54);
	write_cmos_sensor(0x5383, 0x15);
	write_cmos_sensor(0x5384, 0x08);
	write_cmos_sensor(0x5385, 0x75);
	write_cmos_sensor(0x5386, 0x7D);
	write_cmos_sensor(0x5387, 0x81);
	write_cmos_sensor(0x5388, 0x74);
	write_cmos_sensor(0x5389, 0x0D);
	write_cmos_sensor(0x538a, 0x01);
	write_cmos_sensor(0x538b, 0x98);
	/*AE Weight - Average*/
	write_cmos_sensor(0x501d, 0x00);
	write_cmos_sensor(0x5688, 0x11);
	write_cmos_sensor(0x5689, 0x11);
	write_cmos_sensor(0x568a, 0x11);
	write_cmos_sensor(0x568b, 0x11);
	write_cmos_sensor(0x568c, 0x11);
	write_cmos_sensor(0x568d, 0x11);
	write_cmos_sensor(0x568e, 0x11);
	write_cmos_sensor(0x568f, 0x11);
	/*FRAME rate*/
	write_cmos_sensor(0x3212, 0x13);
	write_cmos_sensor(0x3212, 0xa3);

}
static void preview_setting(void)
{
	LOG_INF("E! ");
	/* MIPI_2lane_SXGA(YUV) 1280x960,30fps */
	/* MIPI data rate is 448 Mbps/lane */
#ifndef USE_STREAM
	write_cmos_sensor(0x3103, 0x11);
	write_cmos_sensor(0x3008, 0x82);
	write_cmos_sensor(0x3008, 0x42);
#endif
	write_cmos_sensor(0x3103, 0x03);
	write_cmos_sensor(0x3503, 0x07);
	write_cmos_sensor(0x3002, 0x1c);
	write_cmos_sensor(0x3006, 0xc3);
	write_cmos_sensor(0x300e, 0x45); /* MIPI 2 lane */
	write_cmos_sensor(0x3017, 0x40);
	write_cmos_sensor(0x3018, 0x00);
	write_cmos_sensor(0x302e, 0x0b);
	write_cmos_sensor(0x3037, 0x13);
	write_cmos_sensor(0x3108, 0x01);
	write_cmos_sensor(0x3611, 0x06);
	write_cmos_sensor(0x3612, 0xab);
	write_cmos_sensor(0x3614, 0x50);
	write_cmos_sensor(0x3618, 0x04);
	write_cmos_sensor(0x3034, 0x18);
	write_cmos_sensor(0x3035, 0x21);
	write_cmos_sensor(0x3036, 0x70);
	write_cmos_sensor(0x3500, 0x00);
	write_cmos_sensor(0x3501, 0x01);
	write_cmos_sensor(0x3502, 0x00);
	write_cmos_sensor(0x350a, 0x00);
	write_cmos_sensor(0x350b, 0x3f);
	write_cmos_sensor(0x3600, 0x09);
	write_cmos_sensor(0x3601, 0x43);
	write_cmos_sensor(0x3620, 0x33);
	write_cmos_sensor(0x3621, 0xe0);
	write_cmos_sensor(0x3622, 0x01);
	write_cmos_sensor(0x3630, 0x2d);
	write_cmos_sensor(0x3631, 0x00);
	write_cmos_sensor(0x3632, 0x32);
	write_cmos_sensor(0x3633, 0x52);
	write_cmos_sensor(0x3634, 0x70);
	write_cmos_sensor(0x3635, 0x13);
	write_cmos_sensor(0x3636, 0x03);
	write_cmos_sensor(0x3702, 0x6e);
	write_cmos_sensor(0x3703, 0x52);
	write_cmos_sensor(0x3704, 0xa0);
	write_cmos_sensor(0x3705, 0x33);
	write_cmos_sensor(0x3708, 0x66);
	write_cmos_sensor(0x3709, 0x12);
	write_cmos_sensor(0x370b, 0x61);
	write_cmos_sensor(0x370c, 0xc3);
	write_cmos_sensor(0x370f, 0x10);
	write_cmos_sensor(0x3715, 0x08);
	write_cmos_sensor(0x3717, 0x01);
	write_cmos_sensor(0x371b, 0x20);
	write_cmos_sensor(0x3731, 0x22);
	write_cmos_sensor(0x3739, 0x70);
	write_cmos_sensor(0x3901, 0x0a);
	write_cmos_sensor(0x3905, 0x02);
	write_cmos_sensor(0x3906, 0x10);
	write_cmos_sensor(0x3719, 0x86);
	write_cmos_sensor(0x3800, 0x00);
	write_cmos_sensor(0x3801, 0x00);
	write_cmos_sensor(0x3802, 0x00);
	write_cmos_sensor(0x3803, 0x06);
	write_cmos_sensor(0x3804, 0x0a);
	write_cmos_sensor(0x3805, 0x3f);
	write_cmos_sensor(0x3806, 0x07);
	write_cmos_sensor(0x3807, 0x9d);
	write_cmos_sensor(0x3808, 0x05);
	write_cmos_sensor(0x3809, 0x00);
	write_cmos_sensor(0x380a, 0x03);
	write_cmos_sensor(0x380b, 0xc0);
	write_cmos_sensor(0x380c, 0x07); /*linelength = 0x768=1896*/
	write_cmos_sensor(0x380d, 0x68);
	write_cmos_sensor(0x380e, 0x03); /*framelength = 0x3d8=984*/
	write_cmos_sensor(0x380f, 0xd8);
	write_cmos_sensor(0x3810, 0x00);
	write_cmos_sensor(0x3811, 0x10);
	write_cmos_sensor(0x3812, 0x00);
	write_cmos_sensor(0x3813, 0x06);
	write_cmos_sensor(0x3814, 0x31);
	write_cmos_sensor(0x3815, 0x31);
	write_cmos_sensor(0x3820, 0x41);
	write_cmos_sensor(0x3821, 0x07);
	write_cmos_sensor(0x3824, 0x01);
	write_cmos_sensor(0x3826, 0x03);
	write_cmos_sensor(0x3828, 0x08);
	write_cmos_sensor(0x3a02, 0x03);
	write_cmos_sensor(0x3a03, 0xd8);
	write_cmos_sensor(0x3a08, 0x01);
	write_cmos_sensor(0x3a09, 0xf8);
	write_cmos_sensor(0x3a0a, 0x01);
	write_cmos_sensor(0x3a0b, 0xa4);
	write_cmos_sensor(0x3a0e, 0x02);
	write_cmos_sensor(0x3a0d, 0x02);
	write_cmos_sensor(0x3a14, 0x03);
	write_cmos_sensor(0x3a15, 0xd8);
	write_cmos_sensor(0x3a18, 0x00);
	write_cmos_sensor(0x3a19, 0xf8);
	write_cmos_sensor(0x3c01, 0x34);
	write_cmos_sensor(0x3c04, 0x28);
	write_cmos_sensor(0x3c05, 0x98);
	write_cmos_sensor(0x3c07, 0x07);
	write_cmos_sensor(0x3c09, 0xc2);
	write_cmos_sensor(0x3c0a, 0x9c);
	write_cmos_sensor(0x3c0b, 0x40);
	write_cmos_sensor(0x3c01, 0x34);
	write_cmos_sensor(0x4001, 0x02);
	write_cmos_sensor(0x4004, 0x02);
	write_cmos_sensor(0x4005, 0x18);
	write_cmos_sensor(0x4050, 0x6e);
	write_cmos_sensor(0x4051, 0x8f);
	write_cmos_sensor(0x4300, 0x30);
	write_cmos_sensor(0x4514, 0xbb);
	write_cmos_sensor(0x4520, 0xb0);
	write_cmos_sensor(0x460b, 0x37);
	write_cmos_sensor(0x460c, 0x20);
	write_cmos_sensor(0x4818, 0x01);
	write_cmos_sensor(0x481d, 0xf0);
	write_cmos_sensor(0x481f, 0x50);
	write_cmos_sensor(0x4823, 0x70);
	write_cmos_sensor(0x4831, 0x14);

/* MIPI global timing, settle delay test 0x11 ok for 71*/
	write_cmos_sensor(0x4837, 0x11);

	write_cmos_sensor(0x5000, 0xa7);
	write_cmos_sensor(0x5001, 0x83);
	write_cmos_sensor(0x501d, 0x00);
	write_cmos_sensor(0x501f, 0x00);
	write_cmos_sensor(0x503d, 0x00);
	write_cmos_sensor(0x505c, 0x30);
	write_cmos_sensor(0x5181, 0x59);
	write_cmos_sensor(0x5183, 0x00);
	write_cmos_sensor(0x5191, 0xf0);
	write_cmos_sensor(0x5192, 0x03);
	write_cmos_sensor(0x5684, 0x10);
	write_cmos_sensor(0x5685, 0xa0);
	write_cmos_sensor(0x5686, 0x0c);
	write_cmos_sensor(0x5687, 0x78);
	write_cmos_sensor(0x5a00, 0x08);
	write_cmos_sensor(0x5a21, 0x00);
	write_cmos_sensor(0x5a24, 0x00);
	write_cmos_sensor(0x3008, 0x02);
	write_cmos_sensor(0x3503, 0x00);
	write_cmos_sensor(0x5180, 0xff);
	write_cmos_sensor(0x5181, 0xf2);
	write_cmos_sensor(0x5182, 0x00);
	write_cmos_sensor(0x5183, 0x14);
	write_cmos_sensor(0x5184, 0x25);
	write_cmos_sensor(0x5185, 0x24);
	write_cmos_sensor(0x5186, 0x09);
	write_cmos_sensor(0x5187, 0x09);
	write_cmos_sensor(0x5188, 0x0a);
	write_cmos_sensor(0x5189, 0x75);
	write_cmos_sensor(0x518a, 0x52);
	write_cmos_sensor(0x518b, 0xea);
	write_cmos_sensor(0x518c, 0xa8);
	write_cmos_sensor(0x518d, 0x42);
	write_cmos_sensor(0x518e, 0x38);
	write_cmos_sensor(0x518f, 0x56);
	write_cmos_sensor(0x5190, 0x42);
	write_cmos_sensor(0x5191, 0xf8);
	write_cmos_sensor(0x5192, 0x04);
	write_cmos_sensor(0x5193, 0x70);
	write_cmos_sensor(0x5194, 0xf0);
	write_cmos_sensor(0x5195, 0xf0);
	write_cmos_sensor(0x5196, 0x03);
	write_cmos_sensor(0x5197, 0x01);
	write_cmos_sensor(0x5198, 0x04);
	write_cmos_sensor(0x5199, 0x12);
	write_cmos_sensor(0x519a, 0x04);
	write_cmos_sensor(0x519b, 0x00);
	write_cmos_sensor(0x519c, 0x06);
	write_cmos_sensor(0x519d, 0x82);
	write_cmos_sensor(0x519e, 0x38);
	write_cmos_sensor(0x5381, 0x1e);
	write_cmos_sensor(0x5382, 0x5b);
	write_cmos_sensor(0x5383, 0x08);
	write_cmos_sensor(0x5384, 0x0b);
	write_cmos_sensor(0x5385, 0x84);
	write_cmos_sensor(0x5386, 0x8f);
	write_cmos_sensor(0x5387, 0x82);
	write_cmos_sensor(0x5388, 0x71);
	write_cmos_sensor(0x5389, 0x11);
	write_cmos_sensor(0x538a, 0x01);
	write_cmos_sensor(0x538b, 0x98);
	write_cmos_sensor(0x5300, 0x08);
	write_cmos_sensor(0x5301, 0x1e);
	write_cmos_sensor(0x5302, 0x10);
	write_cmos_sensor(0x5303, 0x00);
	write_cmos_sensor(0x5304, 0x08);
	write_cmos_sensor(0x5305, 0x1e);
	write_cmos_sensor(0x5306, 0x08);
	write_cmos_sensor(0x5307, 0x16);
	write_cmos_sensor(0x5309, 0x08);
	write_cmos_sensor(0x530a, 0x1e);
	write_cmos_sensor(0x530b, 0x04);
	write_cmos_sensor(0x530c, 0x06);
	write_cmos_sensor(0x5480, 0x01);
	write_cmos_sensor(0x5481, 0x0e);
	write_cmos_sensor(0x5482, 0x18);
	write_cmos_sensor(0x5483, 0x2b);
	write_cmos_sensor(0x5484, 0x52);
	write_cmos_sensor(0x5485, 0x65);
	write_cmos_sensor(0x5486, 0x71);
	write_cmos_sensor(0x5487, 0x7d);
	write_cmos_sensor(0x5488, 0x87);
	write_cmos_sensor(0x5489, 0x91);
	write_cmos_sensor(0x548a, 0x9a);
	write_cmos_sensor(0x548b, 0xaa);
	write_cmos_sensor(0x548c, 0xb8);
	write_cmos_sensor(0x548d, 0xcd);
	write_cmos_sensor(0x548e, 0xdd);
	write_cmos_sensor(0x548f, 0xea);
	write_cmos_sensor(0x5490, 0x1d);
	write_cmos_sensor(0x5580, 0x02);
	write_cmos_sensor(0x5583, 0x40);
	write_cmos_sensor(0x5584, 0x30);
	write_cmos_sensor(0x5589, 0x10);
	write_cmos_sensor(0x558a, 0x00);
	write_cmos_sensor(0x558b, 0xf8);
	write_cmos_sensor(0x5780, 0xfc);
	write_cmos_sensor(0x5781, 0x13);
	write_cmos_sensor(0x5782, 0x03);
	write_cmos_sensor(0x5786, 0x20);
	write_cmos_sensor(0x5787, 0x40);
	write_cmos_sensor(0x5788, 0x08);
	write_cmos_sensor(0x5789, 0x08);
	write_cmos_sensor(0x578a, 0x02);
	write_cmos_sensor(0x578b, 0x01);
	write_cmos_sensor(0x578c, 0x01);
	write_cmos_sensor(0x578d, 0x0c);
	write_cmos_sensor(0x578e, 0x02);
	write_cmos_sensor(0x578f, 0x01);
	write_cmos_sensor(0x5790, 0x01);
	write_cmos_sensor(0x5800, 0x3f);
	write_cmos_sensor(0x5801, 0x16);
	write_cmos_sensor(0x5802, 0x0e);
	write_cmos_sensor(0x5803, 0x0d);
	write_cmos_sensor(0x5804, 0x17);
	write_cmos_sensor(0x5805, 0x3f);
	write_cmos_sensor(0x5806, 0x0b);
	write_cmos_sensor(0x5807, 0x06);
	write_cmos_sensor(0x5808, 0x04);
	write_cmos_sensor(0x5809, 0x04);
	write_cmos_sensor(0x580a, 0x06);
	write_cmos_sensor(0x580b, 0x0b);
	write_cmos_sensor(0x580c, 0x09);
	write_cmos_sensor(0x580d, 0x03);
	write_cmos_sensor(0x580e, 0x00);
	write_cmos_sensor(0x580f, 0x00);
	write_cmos_sensor(0x5810, 0x03);
	write_cmos_sensor(0x5811, 0x08);
	write_cmos_sensor(0x5812, 0x0a);
	write_cmos_sensor(0x5813, 0x03);
	write_cmos_sensor(0x5814, 0x00);
	write_cmos_sensor(0x5815, 0x00);
	write_cmos_sensor(0x5816, 0x04);
	write_cmos_sensor(0x5817, 0x09);
	write_cmos_sensor(0x5818, 0x0f);
	write_cmos_sensor(0x5819, 0x08);
	write_cmos_sensor(0x581a, 0x06);
	write_cmos_sensor(0x581b, 0x06);
	write_cmos_sensor(0x581c, 0x08);
	write_cmos_sensor(0x581d, 0x0c);
	write_cmos_sensor(0x581e, 0x3f);
	write_cmos_sensor(0x581f, 0x1e);
	write_cmos_sensor(0x5820, 0x12);
	write_cmos_sensor(0x5821, 0x13);
	write_cmos_sensor(0x5822, 0x21);
	write_cmos_sensor(0x5823, 0x3f);
	write_cmos_sensor(0x5824, 0x68);
	write_cmos_sensor(0x5825, 0x28);
	write_cmos_sensor(0x5826, 0x2c);
	write_cmos_sensor(0x5827, 0x28);
	write_cmos_sensor(0x5828, 0x08);
	write_cmos_sensor(0x5829, 0x48);
	write_cmos_sensor(0x582a, 0x64);
	write_cmos_sensor(0x582b, 0x62);
	write_cmos_sensor(0x582c, 0x64);
	write_cmos_sensor(0x582d, 0x28);
	write_cmos_sensor(0x582e, 0x46);
	write_cmos_sensor(0x582f, 0x62);
	write_cmos_sensor(0x5830, 0x60);
	write_cmos_sensor(0x5831, 0x62);
	write_cmos_sensor(0x5832, 0x26);
	write_cmos_sensor(0x5833, 0x48);
	write_cmos_sensor(0x5834, 0x66);
	write_cmos_sensor(0x5835, 0x44);
	write_cmos_sensor(0x5836, 0x64);
	write_cmos_sensor(0x5837, 0x28);
	write_cmos_sensor(0x5838, 0x66);
	write_cmos_sensor(0x5839, 0x48);
	write_cmos_sensor(0x583a, 0x2c);
	write_cmos_sensor(0x583b, 0x28);
	write_cmos_sensor(0x583c, 0x26);
	write_cmos_sensor(0x583d, 0xae);
	write_cmos_sensor(0x5025, 0x00);
	write_cmos_sensor(0x3a0f, 0x38);
	write_cmos_sensor(0x3a10, 0x30);
	write_cmos_sensor(0x3a11, 0x70);
	write_cmos_sensor(0x3a1b, 0x38);
	write_cmos_sensor(0x3a1e, 0x30);
	write_cmos_sensor(0x3a1f, 0x18);
#ifndef USE_STREAM
	write_cmos_sensor(0x3008, 0x02);
#endif
}

static void set_scenemode_night(void)
{
	LOG_INF("E\n");
	write_cmos_sensor(0x3212, 0x03);
	write_cmos_sensor(0x3A00, 0x3c);
	write_cmos_sensor(0x3a02, 0x17);
	write_cmos_sensor(0x3a03, 0x10);
	write_cmos_sensor(0x3a14, 0x17);
	write_cmos_sensor(0x3a15, 0x10);
	/*CMX*/
	write_cmos_sensor(0x5381, 0x21); /* CCM */
	write_cmos_sensor(0x5382, 0x54);
	write_cmos_sensor(0x5383, 0x15);
	write_cmos_sensor(0x5384, 0x08);
	write_cmos_sensor(0x5385, 0x75);
	write_cmos_sensor(0x5386, 0x7D);
	write_cmos_sensor(0x5387, 0x81);
	write_cmos_sensor(0x5388, 0x74);
	write_cmos_sensor(0x5389, 0x0D);
	write_cmos_sensor(0x538a, 0x01);
	write_cmos_sensor(0x538b, 0x98);
	/*AE Weight - Average*/
	write_cmos_sensor(0x501d, 0x00);
	write_cmos_sensor(0x5688, 0x11);
	write_cmos_sensor(0x5689, 0x11);
	write_cmos_sensor(0x568a, 0x11);
	write_cmos_sensor(0x568b, 0x11);
	write_cmos_sensor(0x568c, 0x11);
	write_cmos_sensor(0x568d, 0x11);
	write_cmos_sensor(0x568e, 0x11);
	write_cmos_sensor(0x568f, 0x11);
	/*FRAME rate*/
	write_cmos_sensor(0x3212, 0x13);
	write_cmos_sensor(0x3212, 0xa3);
}

static void set_scenemode_off(void)
{
	LOG_INF("E\n");
	write_cmos_sensor(0x3212, 0x03);
	write_cmos_sensor(0x3A00, 0x3c); /* 10-30 */
	write_cmos_sensor(0x3a02, 0x0b);
	write_cmos_sensor(0x3a03, 0x88);
	write_cmos_sensor(0x3a14, 0x0b);
	write_cmos_sensor(0x3a15, 0x88);
	/*CMX*/
	write_cmos_sensor(0x5381, 0x21); /* CCM */
	write_cmos_sensor(0x5382, 0x54);
	write_cmos_sensor(0x5383, 0x15);
	write_cmos_sensor(0x5384, 0x08);
	write_cmos_sensor(0x5385, 0x75);
	write_cmos_sensor(0x5386, 0x7D);
	write_cmos_sensor(0x5387, 0x81);
	write_cmos_sensor(0x5388, 0x74);
	write_cmos_sensor(0x5389, 0x0D);
	write_cmos_sensor(0x538a, 0x01);
	write_cmos_sensor(0x538b, 0x98);
	/*AE Weight - Average*/
	write_cmos_sensor(0x501d, 0x00);
	write_cmos_sensor(0x5688, 0x11);
	write_cmos_sensor(0x5689, 0x11);
	write_cmos_sensor(0x568a, 0x11);
	write_cmos_sensor(0x568b, 0x11);
	write_cmos_sensor(0x568c, 0x11);
	write_cmos_sensor(0x568d, 0x11);
	write_cmos_sensor(0x568e, 0x11);
	write_cmos_sensor(0x568f, 0x11);
		/*FRAME rate*/
	write_cmos_sensor(0x3212, 0x13);
	write_cmos_sensor(0x3212, 0xa3);
}
static void  set_scene_mode(UINT16 para)
{
	LOG_INF("E imgsensor.scene_mode = %d\n", para);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.scene_mode = para;
	spin_unlock(&imgsensor_drv_lock);
	switch (para) {
	case SCENE_MODE_NIGHTSCENE:
		set_scenemode_night();
		break;
	case SCENE_MODE_PORTRAIT:
		set_scenemode_portrait();
		break;
	case SCENE_MODE_LANDSCAPE:
		set_scenemode_landscape();
		break;
	case SCENE_MODE_SUNSET:
		set_scenemode_sunset();
		break;
	case SCENE_MODE_SPORTS:
		set_scenemode_sports();
		break;
	case SCENE_MODE_HDR:
		break;
	case SCENE_MODE_OFF:
	default:
		set_scenemode_off();
		break;
	}

}

static void set_iso(UINT16 para)
{
	LOG_INF("E ISO=%d\n", para);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.iso_speed = para;
	spin_unlock(&imgsensor_drv_lock);
	switch (para) {
	case AE_ISO_100:
	case AE_ISO_AUTO:
		write_cmos_sensor(0x3a18, 0x00);
		write_cmos_sensor(0x3a19, 0x60);
		break;
	case AE_ISO_200:
		write_cmos_sensor(0x3a18, 0x00);
		write_cmos_sensor(0x3a19, 0x90);
		break;
	case AE_ISO_400:
		write_cmos_sensor(0x3a18, 0x00);
		write_cmos_sensor(0x3a19, 0xc0);
		break;
	default:
		break;
	}

}

static BOOL set_param_effect(UINT16 para)
{
	LOG_INF("E effect=%d\n", para);
	switch (para) {
	case MEFFECT_OFF:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5580, 0x06);
		write_cmos_sensor(0x5583, 0x40);
		write_cmos_sensor(0x5584, 0x28);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case MEFFECT_SEPIA:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5580, 0x1e);
		write_cmos_sensor(0x5583, 0x40);
		write_cmos_sensor(0x5584, 0xa0);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case MEFFECT_NEGATIVE:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5580, 0x46);
		write_cmos_sensor(0x5583, 0x40);
		write_cmos_sensor(0x5584, 0x28);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case MEFFECT_SEPIAGREEN:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5580, 0x1e);
		write_cmos_sensor(0x5583, 0x60);
		write_cmos_sensor(0x5584, 0x60);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case MEFFECT_SEPIABLUE:
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5580, 0x1e);
		write_cmos_sensor(0x5583, 0xa0);
		write_cmos_sensor(0x5584, 0x40);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	case MEFFECT_MONO: /* B&W */
		write_cmos_sensor(0x3212, 0x03);
		write_cmos_sensor(0x5580, 0x1e);
		write_cmos_sensor(0x5583, 0x80);
		write_cmos_sensor(0x5584, 0x80);
		write_cmos_sensor(0x3212, 0x13);
		write_cmos_sensor(0x3212, 0xa3);
		break;
	default:
		return KAL_FALSE;
	}
	return KAL_FALSE;
} /* OV5645MIPI_set_param_effect */

static BOOL set_flicker_mode(UINT16 para)
{
	LOG_INF("E flicker=%d\n", para);
	switch (para) {
	case AE_FLICKER_MODE_50HZ:
		write_cmos_sensor(0x3c00, 0x04);
		write_cmos_sensor(0x3c01, 0x80);
		break;
	case AE_FLICKER_MODE_60HZ:
		write_cmos_sensor(0x3c00, 0x00);
		write_cmos_sensor(0x3c01, 0x80);
		break;
	case AE_FLICKER_MODE_AUTO:
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
static BOOL set_ev(UINT16 para)
{
	LOG_INF("E ev=%d\n", para);
	switch (para) {
	case AE_EV_COMP_20:
		write_cmos_sensor(0x3a0f, 0x50); /* AEC in H */
		write_cmos_sensor(0x3a10, 0x48); /* AEC in L */
		write_cmos_sensor(0x3a11, 0x90); /* AEC out H */
		write_cmos_sensor(0x3a1b, 0x50); /* AEC out L */
		write_cmos_sensor(0x3a1e, 0x48); /* control zone H */
		write_cmos_sensor(0x3a1f, 0x24); /* control zone L */
		break;
	case AE_EV_COMP_10:
		write_cmos_sensor(0x3a0f, 0x40); /* AEC in H */
		write_cmos_sensor(0x3a10, 0x38); /* AEC in L */
		write_cmos_sensor(0x3a11, 0x80); /* AEC out H */
		write_cmos_sensor(0x3a1b, 0x40); /* AEC out L */
		write_cmos_sensor(0x3a1e, 0x38); /* control zone H */
		write_cmos_sensor(0x3a1f, 0x1c); /* control zone L */
		break;
	case AE_EV_COMP_00:
		write_cmos_sensor(0x3a0f, 0x30); /* AEC in H */
		write_cmos_sensor(0x3a10, 0x28); /* AEC in L */
		write_cmos_sensor(0x3a11, 0x60); /* AEC out H */
		write_cmos_sensor(0x3a1b, 0x30); /* AEC out L */
		write_cmos_sensor(0x3a1e, 0x28); /* control zone H */
		write_cmos_sensor(0x3a1f, 0x14); /* control zone L */
		break;
	case AE_EV_COMP_n10:
		write_cmos_sensor(0x3a0f, 0x20); /* AEC in H */
		write_cmos_sensor(0x3a10, 0x18); /* AEC in L */
		write_cmos_sensor(0x3a11, 0x41); /* AEC out H */
		write_cmos_sensor(0x3a1b, 0x20); /* AEC out L */
		write_cmos_sensor(0x3a1e, 0x18); /* control zone H */
		write_cmos_sensor(0x3a1f, 0x10); /* control zone L */
		break;
	case AE_EV_COMP_n20: /* -2 EV */
		write_cmos_sensor(0x3a0f, 0x18); /* AEC in H */
		write_cmos_sensor(0x3a10, 0x14); /* AEC in L */
		write_cmos_sensor(0x3a11, 0x32); /* AEC out H */
		write_cmos_sensor(0x3a1b, 0x18); /* AEC out L */
		write_cmos_sensor(0x3a1e, 0x14); /* control zone H */
		write_cmos_sensor(0x3a1f, 0x0c); /* control zone L */
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
static UINT32 set_yuv_cmd(enum FEATURE_ID iCmd, UINT32 iPara)
{
	LOG_INF("E iCmd=%d,iPara=%d\n", iCmd, iPara);
	switch (iCmd) {
	case FID_SCENE_MODE: /* auto mode or night mode */
		set_scene_mode(iPara);
		break;
	case FID_AWB_MODE:
		set_param_wb(iPara);
		break;
	case FID_COLOR_EFFECT:
		set_param_effect(iPara);
		break;
	case FID_AE_EV:
		set_ev(iPara);
		break;
	case FID_AE_FLICKER:
		set_flicker_mode(iPara);
		break;
	case FID_ISP_CONTRAST:
		set_contrast(iPara);
		break;
	case FID_ISP_BRIGHT:
		set_brightness(iPara);
		break;
	case FID_ISP_SAT:
		set_saturation(iPara);
		break;
	case FID_AE_ISO:
		set_iso(iPara);
		break;
	case FID_ISP_HUE:
		break;
	case FID_ISP_EDGE:
		break;
	default:
		break;
	}
	return TRUE;
}
static void sensor_init(void)
{
	LOG_INF("E!");
	/* MIPI_2lane_SXGA(YUV) 1280x960,30fps */
	preview_setting();
}

static void capture_setting(void)
{
	LOG_INF("E!\n");
	/* MIPI_2lane_5M(YUV), 2592*1944, 15fps */
	/* MIPI data rate is 672 Mbps/lane */
#ifndef USE_STREAM
	write_cmos_sensor(0x3103, 0x11);
	write_cmos_sensor(0x3008, 0x82);
	write_cmos_sensor(0x3008, 0x42);
#endif
	write_cmos_sensor(0x3103, 0x03);
	write_cmos_sensor(0x3503, 0x07);
	write_cmos_sensor(0x3002, 0x1c);
	write_cmos_sensor(0x3006, 0xc3);
	write_cmos_sensor(0x300e, 0x45);
	write_cmos_sensor(0x3017, 0x40);
	write_cmos_sensor(0x3018, 0x00);
	write_cmos_sensor(0x302e, 0x0b);
	write_cmos_sensor(0x3037, 0x13);
	write_cmos_sensor(0x3108, 0x01);
	write_cmos_sensor(0x3611, 0x06);
	write_cmos_sensor(0x3612, 0xab);
	write_cmos_sensor(0x3614, 0x50);
	write_cmos_sensor(0x3618, 0x04);
	write_cmos_sensor(0x3034, 0x18); /* PLL, MIPI 8-bit mode */
	write_cmos_sensor(0x3035, 0x11);
	write_cmos_sensor(0x3036, 0x54);
	write_cmos_sensor(0x3500, 0x00);
	write_cmos_sensor(0x3501, 0x01);
	write_cmos_sensor(0x3502, 0x00);
	write_cmos_sensor(0x350a, 0x00);
	write_cmos_sensor(0x350b, 0x3f);
	write_cmos_sensor(0x3600, 0x08);
	write_cmos_sensor(0x3601, 0x33);
	write_cmos_sensor(0x3620, 0x33);
	write_cmos_sensor(0x3621, 0xe0);
	write_cmos_sensor(0x3622, 0x01);
	write_cmos_sensor(0x3630, 0x2d);
	write_cmos_sensor(0x3631, 0x00);
	write_cmos_sensor(0x3632, 0x32);
	write_cmos_sensor(0x3633, 0x52);
	write_cmos_sensor(0x3634, 0x70);
	write_cmos_sensor(0x3635, 0x13);
	write_cmos_sensor(0x3636, 0x03);
	write_cmos_sensor(0x3702, 0x6e);
	write_cmos_sensor(0x3703, 0x52);
	write_cmos_sensor(0x3704, 0xa0);
	write_cmos_sensor(0x3705, 0x33);
	write_cmos_sensor(0x3708, 0x63);
	write_cmos_sensor(0x3709, 0x12);
	write_cmos_sensor(0x370b, 0x61);
	write_cmos_sensor(0x370c, 0xc0);
	write_cmos_sensor(0x370f, 0x10);
	write_cmos_sensor(0x3715, 0x08);
	write_cmos_sensor(0x3717, 0x01);
	write_cmos_sensor(0x371b, 0x20);
	write_cmos_sensor(0x3731, 0x22);
	write_cmos_sensor(0x3739, 0x70);
	write_cmos_sensor(0x3901, 0x0a);
	write_cmos_sensor(0x3905, 0x02);
	write_cmos_sensor(0x3906, 0x10);
	write_cmos_sensor(0x3719, 0x86);
	write_cmos_sensor(0x3800, 0x00);
	write_cmos_sensor(0x3801, 0x00);
	write_cmos_sensor(0x3802, 0x00);
	write_cmos_sensor(0x3803, 0x00);
	write_cmos_sensor(0x3804, 0x0a);
	write_cmos_sensor(0x3805, 0x3f);
	write_cmos_sensor(0x3806, 0x07);
	write_cmos_sensor(0x3807, 0x9f);
	write_cmos_sensor(0x3808, 0x0a);
	write_cmos_sensor(0x3809, 0x20);
	write_cmos_sensor(0x380a, 0x07);
	write_cmos_sensor(0x380b, 0x98);
	write_cmos_sensor(0x380c, 0x0b);
	write_cmos_sensor(0x380d, 0x1c);
	write_cmos_sensor(0x380e, 0x07);
	write_cmos_sensor(0x380f, 0xb0);
	write_cmos_sensor(0x3810, 0x00);
	write_cmos_sensor(0x3811, 0x10);
	write_cmos_sensor(0x3812, 0x00);
	write_cmos_sensor(0x3813, 0x06);
	write_cmos_sensor(0x3814, 0x11);
	write_cmos_sensor(0x3815, 0x11);
	write_cmos_sensor(0x3820, 0x40);
	write_cmos_sensor(0x3821, 0x06);
	write_cmos_sensor(0x3824, 0x01);
	write_cmos_sensor(0x3826, 0x03);
	write_cmos_sensor(0x3828, 0x08);
	write_cmos_sensor(0x3a02, 0x07);
	write_cmos_sensor(0x3a03, 0xb0);
	write_cmos_sensor(0x3a08, 0x01);
	write_cmos_sensor(0x3a09, 0x27);
	write_cmos_sensor(0x3a0a, 0x00);
	write_cmos_sensor(0x3a0b, 0xf6);
	write_cmos_sensor(0x3a0e, 0x06);
	write_cmos_sensor(0x3a0d, 0x08);
	write_cmos_sensor(0x3a14, 0x07);
	write_cmos_sensor(0x3a15, 0xb0);
	write_cmos_sensor(0x3a18, 0x00);
	write_cmos_sensor(0x3a19, 0xf8);
	write_cmos_sensor(0x3c01, 0x34);
	write_cmos_sensor(0x3c04, 0x28);
	write_cmos_sensor(0x3c05, 0x98);
	write_cmos_sensor(0x3c07, 0x07);
	write_cmos_sensor(0x3c09, 0xc2);
	write_cmos_sensor(0x3c0a, 0x9c);
	write_cmos_sensor(0x3c0b, 0x40);
	write_cmos_sensor(0x3c01, 0x34);
	write_cmos_sensor(0x4001, 0x02);
	write_cmos_sensor(0x4004, 0x06);
	write_cmos_sensor(0x4005, 0x18);
	write_cmos_sensor(0x4050, 0x6e);
	write_cmos_sensor(0x4051, 0x8f);
	write_cmos_sensor(0x4300, 0x30); /* YUV 422, YUYV */
	write_cmos_sensor(0x4514, 0x00);
	write_cmos_sensor(0x4520, 0xb0);
	write_cmos_sensor(0x460b, 0x37);
	write_cmos_sensor(0x460c, 0x20);
	write_cmos_sensor(0x4818, 0x01);
	write_cmos_sensor(0x481d, 0xf0);
	write_cmos_sensor(0x481f, 0x50);
	write_cmos_sensor(0x4823, 0x70);
	write_cmos_sensor(0x4831, 0x14);
	write_cmos_sensor(0x4837, 0x0b); /* MIPI global timing */
	/* Lenc on, raw gamma on, BPC on, WPC on, color interpolation on */
	write_cmos_sensor(0x5000, 0xa7);
	write_cmos_sensor(0x5001, 0x83);
	write_cmos_sensor(0x501d, 0x00);
	write_cmos_sensor(0x501f, 0x00); /* select ISP YUV 422 */
	write_cmos_sensor(0x503d, 0x00);
	write_cmos_sensor(0x505c, 0x30);
	write_cmos_sensor(0x5181, 0x59);
	write_cmos_sensor(0x5183, 0x00);
	write_cmos_sensor(0x5191, 0xf0);
	write_cmos_sensor(0x5192, 0x03);
	write_cmos_sensor(0x5684, 0x10);
	write_cmos_sensor(0x5685, 0xa0);
	write_cmos_sensor(0x5686, 0x0c);
	write_cmos_sensor(0x5687, 0x78);
	write_cmos_sensor(0x5a00, 0x08);
	write_cmos_sensor(0x5a21, 0x00);
	write_cmos_sensor(0x5a24, 0x00);
	write_cmos_sensor(0x3008, 0x02);
	write_cmos_sensor(0x3503, 0x00);
	write_cmos_sensor(0x5180, 0xff);
	write_cmos_sensor(0x5181, 0xf2);
	write_cmos_sensor(0x5182, 0x00);
	write_cmos_sensor(0x5183, 0x14);
	write_cmos_sensor(0x5184, 0x25);
	write_cmos_sensor(0x5185, 0x24);
	write_cmos_sensor(0x5186, 0x09);
	write_cmos_sensor(0x5187, 0x09);
	write_cmos_sensor(0x5188, 0x0a);
	write_cmos_sensor(0x5189, 0x75);
	write_cmos_sensor(0x518a, 0x52);
	write_cmos_sensor(0x518b, 0xea);
	write_cmos_sensor(0x518c, 0xa8);
	write_cmos_sensor(0x518d, 0x42);
	write_cmos_sensor(0x518e, 0x38);
	write_cmos_sensor(0x518f, 0x56);
	write_cmos_sensor(0x5190, 0x42);
	write_cmos_sensor(0x5191, 0xf8);
	write_cmos_sensor(0x5192, 0x04);
	write_cmos_sensor(0x5193, 0x70);
	write_cmos_sensor(0x5194, 0xf0);
	write_cmos_sensor(0x5195, 0xf0);
	write_cmos_sensor(0x5196, 0x03);
	write_cmos_sensor(0x5197, 0x01);
	write_cmos_sensor(0x5198, 0x04);
	write_cmos_sensor(0x5199, 0x12);
	write_cmos_sensor(0x519a, 0x04);
	write_cmos_sensor(0x519b, 0x00);
	write_cmos_sensor(0x519c, 0x06);
	write_cmos_sensor(0x519d, 0x82);
	write_cmos_sensor(0x519e, 0x38);
	write_cmos_sensor(0x5381, 0x1e);
	write_cmos_sensor(0x5382, 0x5b);
	write_cmos_sensor(0x5383, 0x08);
	write_cmos_sensor(0x5384, 0x0b);
	write_cmos_sensor(0x5385, 0x84);
	write_cmos_sensor(0x5386, 0x8f);
	write_cmos_sensor(0x5387, 0x82);
	write_cmos_sensor(0x5388, 0x71);
	write_cmos_sensor(0x5389, 0x11);
	write_cmos_sensor(0x538a, 0x01);
	write_cmos_sensor(0x538b, 0x98);
	write_cmos_sensor(0x5300, 0x08);
	write_cmos_sensor(0x5301, 0x1e);
	write_cmos_sensor(0x5302, 0x10);
	write_cmos_sensor(0x5303, 0x00);
	write_cmos_sensor(0x5304, 0x08);
	write_cmos_sensor(0x5305, 0x1e);
	write_cmos_sensor(0x5306, 0x08);
	write_cmos_sensor(0x5307, 0x16);
	write_cmos_sensor(0x5309, 0x08);
	write_cmos_sensor(0x530a, 0x1e);
	write_cmos_sensor(0x530b, 0x04);
	write_cmos_sensor(0x530c, 0x06);
	write_cmos_sensor(0x5480, 0x01);
	write_cmos_sensor(0x5481, 0x0e);
	write_cmos_sensor(0x5482, 0x18);
	write_cmos_sensor(0x5483, 0x2b);
	write_cmos_sensor(0x5484, 0x52);
	write_cmos_sensor(0x5485, 0x65);
	write_cmos_sensor(0x5486, 0x71);
	write_cmos_sensor(0x5487, 0x7d);
	write_cmos_sensor(0x5488, 0x87);
	write_cmos_sensor(0x5489, 0x91);
	write_cmos_sensor(0x548a, 0x9a);
	write_cmos_sensor(0x548b, 0xaa);
	write_cmos_sensor(0x548c, 0xb8);
	write_cmos_sensor(0x548d, 0xcd);
	write_cmos_sensor(0x548e, 0xdd);
	write_cmos_sensor(0x548f, 0xea);
	write_cmos_sensor(0x5490, 0x1d);
	write_cmos_sensor(0x5580, 0x02);
	write_cmos_sensor(0x5583, 0x40);
	write_cmos_sensor(0x5584, 0x30);
	write_cmos_sensor(0x5589, 0x10);
	write_cmos_sensor(0x558a, 0x00);
	write_cmos_sensor(0x558b, 0xf8);
	write_cmos_sensor(0x5780, 0xfc);
	write_cmos_sensor(0x5781, 0x13);
	write_cmos_sensor(0x5782, 0x03);
	write_cmos_sensor(0x5786, 0x20);
	write_cmos_sensor(0x5787, 0x40);
	write_cmos_sensor(0x5788, 0x08);
	write_cmos_sensor(0x5789, 0x08);
	write_cmos_sensor(0x578a, 0x02);
	write_cmos_sensor(0x578b, 0x01);
	write_cmos_sensor(0x578c, 0x01);
	write_cmos_sensor(0x578d, 0x0c);
	write_cmos_sensor(0x578e, 0x02);
	write_cmos_sensor(0x578f, 0x01);
	write_cmos_sensor(0x5790, 0x01);
	write_cmos_sensor(0x5800, 0x3f);
	write_cmos_sensor(0x5801, 0x16);
	write_cmos_sensor(0x5802, 0x0e);
	write_cmos_sensor(0x5803, 0x0d);
	write_cmos_sensor(0x5804, 0x17);
	write_cmos_sensor(0x5805, 0x3f);
	write_cmos_sensor(0x5806, 0x0b);
	write_cmos_sensor(0x5807, 0x06);
	write_cmos_sensor(0x5808, 0x04);
	write_cmos_sensor(0x5809, 0x04);
	write_cmos_sensor(0x580a, 0x06);
	write_cmos_sensor(0x580b, 0x0b);
	write_cmos_sensor(0x580c, 0x09);
	write_cmos_sensor(0x580d, 0x03);
	write_cmos_sensor(0x580e, 0x00);
	write_cmos_sensor(0x580f, 0x00);
	write_cmos_sensor(0x5810, 0x03);
	write_cmos_sensor(0x5811, 0x08);
	write_cmos_sensor(0x5812, 0x0a);
	write_cmos_sensor(0x5813, 0x03);
	write_cmos_sensor(0x5814, 0x00);
	write_cmos_sensor(0x5815, 0x00);
	write_cmos_sensor(0x5816, 0x04);
	write_cmos_sensor(0x5817, 0x09);
	write_cmos_sensor(0x5818, 0x0f);
	write_cmos_sensor(0x5819, 0x08);
	write_cmos_sensor(0x581a, 0x06);
	write_cmos_sensor(0x581b, 0x06);
	write_cmos_sensor(0x581c, 0x08);
	write_cmos_sensor(0x581d, 0x0c);
	write_cmos_sensor(0x581e, 0x3f);
	write_cmos_sensor(0x581f, 0x1e);
	write_cmos_sensor(0x5820, 0x12);
	write_cmos_sensor(0x5821, 0x13);
	write_cmos_sensor(0x5822, 0x21);
	write_cmos_sensor(0x5823, 0x3f);
	write_cmos_sensor(0x5824, 0x68);
	write_cmos_sensor(0x5825, 0x28);
	write_cmos_sensor(0x5826, 0x2c);
	write_cmos_sensor(0x5827, 0x28);
	write_cmos_sensor(0x5828, 0x08);
	write_cmos_sensor(0x5829, 0x48);
	write_cmos_sensor(0x582a, 0x64);
	write_cmos_sensor(0x582b, 0x62);
	write_cmos_sensor(0x582c, 0x64);
	write_cmos_sensor(0x582d, 0x28);
	write_cmos_sensor(0x582e, 0x46);
	write_cmos_sensor(0x582f, 0x62);
	write_cmos_sensor(0x5830, 0x60);
	write_cmos_sensor(0x5831, 0x62);
	write_cmos_sensor(0x5832, 0x26);
	write_cmos_sensor(0x5833, 0x48);
	write_cmos_sensor(0x5834, 0x66);
	write_cmos_sensor(0x5835, 0x44);
	write_cmos_sensor(0x5836, 0x64);
	write_cmos_sensor(0x5837, 0x28);
	write_cmos_sensor(0x5838, 0x66);
	write_cmos_sensor(0x5839, 0x48);
	write_cmos_sensor(0x583a, 0x2c);
	write_cmos_sensor(0x583b, 0x28);
	write_cmos_sensor(0x583c, 0x26);
	write_cmos_sensor(0x583d, 0xae);
	write_cmos_sensor(0x5025, 0x00);
	write_cmos_sensor(0x3a0f, 0x38);
	write_cmos_sensor(0x3a10, 0x30);
	write_cmos_sensor(0x3a11, 0x70);
	write_cmos_sensor(0x3a1b, 0x38);
	write_cmos_sensor(0x3a1e, 0x30);
	write_cmos_sensor(0x3a1f, 0x18);
#ifndef USE_STREAM
	write_cmos_sensor(0x3008, 0x02);
#endif
}
static void hs_video_setting(void)
{
	LOG_INF("E!");
	capture_setting();
}
static void normal_video_setting(void)
{
	LOG_INF("E!");
	capture_setting();
}

static void slim_video_setting(void)
{
	LOG_INF("E!");
	capture_setting();
}
static UINT32 set_video_mode(UINT16 u2FrameRate)
{
	LOG_INF("E u2FrameRate=%d\n", u2FrameRate);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = KAL_TRUE;
	spin_unlock(&imgsensor_drv_lock);
	if (u2FrameRate == 30)
		set_max_framerate(30);
	else if (u2FrameRate == 15)
		set_max_framerate(15);
	else
		LOG_INF("Wrong frame rate setting\n");

	return TRUE;
}
static void set_max_min_fps(UINT32 u2MinFrameRate, UINT32 u2MaxFrameRate)
{
	LOG_INF("E:FrameRate= %d %d\n", u2MinFrameRate, u2MaxFrameRate);
	spin_lock(&imgsensor_drv_lock);
	imgsensor_info.minframerate = u2MinFrameRate;
	imgsensor_info.maxframerate = u2MaxFrameRate;
	spin_unlock(&imgsensor_drv_lock);
	if ((imgsensor_info.minframerate == 15) &&
		(imgsensor_info.maxframerate == 30))
		set_max_framerate(30); /* video_setting(); */

	if ((imgsensor_info.minframerate == 15) &&
		(imgsensor_info.maxframerate == 15))
		set_max_framerate(15); /* video_setting(); */

}

static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
{
	kal_uint8 i = 0;
	kal_uint8 retry = 2;
	/* sensor have two i2c address 0x6c 0x6d & 0x21 0x20,
	 * we should detect the module used i2c address
	 */
	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
		spin_lock(&imgsensor_drv_lock);
		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
		spin_unlock(&imgsensor_drv_lock);
		do {
			*sensor_id = (read_cmos_sensor(0x300A) << 8) |
					read_cmos_sensor(0x300B);
			/* *sensor_id = imgsensor_info.sensor_id; */
			if (*sensor_id == imgsensor_info.sensor_id) {
				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n",
					imgsensor.i2c_write_id, *sensor_id);
				return ERROR_NONE;
			}
			LOG_INF(
			  "Read sensor id fail, id: 0x%x, i2c write id: 0x%x\n"
			  , *sensor_id, imgsensor.i2c_write_id);
			retry--;
		} while (retry > 0);
		i++;
		retry = 2;
	}
	if (*sensor_id != imgsensor_info.sensor_id) {
		/* if Sensor ID is not correct,
		 * Must set *sensor_id to 0xFFFFFFFF
		 */
		*sensor_id = 0xFFFFFFFF;
		return ERROR_SENSOR_CONNECT_FAIL;
	}
	return ERROR_NONE;
}
static UINT32 open(void)
{
	/* const kal_uint8 i2c_addr[] =
	 *	{IMGSENSOR_WRITE_ID_1, IMGSENSOR_WRITE_ID_2};
	 */
	kal_uint8 i = 0;
	kal_uint8 retry = 2;
	kal_uint16 sensor_id = 0;

	LOG_1;
	/*LOG_2;*/
	/* sensor have two i2c address 0x5a 0x5b & 0x21 0x20,
	 * we should detect the module used i2c address
	 */
	while (imgsensor_info.i2c_addr_table[i] != 0xff) {
		spin_lock(&imgsensor_drv_lock);
		imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
		spin_unlock(&imgsensor_drv_lock);
		do {
			sensor_id = (read_cmos_sensor(0x300A) << 8) |
				read_cmos_sensor(0x300B);
			/*sensor_id = imgsensor_info.sensor_id;*/
			if (sensor_id == imgsensor_info.sensor_id) {
				LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n",
					imgsensor.i2c_write_id, sensor_id);
				break;
			}
			LOG_INF(
			  "Read sensor id fail, id: 0x%x, i2c write id: 0x%x\n"
			  , sensor_id, imgsensor.i2c_write_id);
			retry--;
		} while (retry > 0);
		i++;
		if (sensor_id == imgsensor_info.sensor_id)
			break;
		retry = 2;
	}
	if (imgsensor_info.sensor_id != sensor_id)
		return ERROR_SENSOR_CONNECT_FAIL;
	/* initail sequence write in */
	sensor_init();
	af_Init();
	spin_lock(&imgsensor_drv_lock);

	imgsensor.autoflicker_en = KAL_FALSE;
	imgsensor.sensor_mode = IMGSENSOR_MODE_INIT;
	imgsensor.pclk = imgsensor_info.pre.pclk;
	imgsensor.frame_length = imgsensor_info.pre.framelength;
	imgsensor.line_length = imgsensor_info.pre.linelength;
	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
	imgsensor.dummy_pixel = 0;
	imgsensor.dummy_line = 0;
	imgsensor.ihdr_en = KAL_FALSE;
	imgsensor.test_pattern = KAL_FALSE;
	imgsensor.current_fps = imgsensor_info.pre.max_framerate;
	spin_unlock(&imgsensor_drv_lock);

	return ERROR_NONE;
}
static UINT32 close(void)
{
	LOG_INF("E\n");
	/*No Need to implement this function*/

	return ERROR_NONE;
}

static kal_uint32 preview(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
		MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E\n");
	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_PREVIEW;
	imgsensor.pclk = imgsensor_info.pre.pclk;
	/*imgsensor.video_mode = KAL_FALSE;*/
	imgsensor.line_length = imgsensor_info.pre.linelength;
	imgsensor.frame_length = imgsensor_info.pre.framelength;
	imgsensor.min_frame_length = imgsensor_info.pre.framelength;
	imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	preview_setting();
	/*set_mirror_flip(IMAGE_NORMAL);*/
	return ERROR_NONE;
}
static kal_uint32 capture(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
		MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E");
	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_CAPTURE;
	imgsensor.pclk = imgsensor_info.cap.pclk;
	imgsensor.line_length = imgsensor_info.cap.linelength;
	imgsensor.frame_length = imgsensor_info.cap.framelength;
	imgsensor.min_frame_length = imgsensor_info.cap.framelength;
	imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	capture_setting();
	return ERROR_NONE;
}
static kal_uint32 normal_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
		MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E");

	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_VIDEO;
	imgsensor.pclk = imgsensor_info.normal_video.pclk;
	imgsensor.line_length = imgsensor_info.normal_video.linelength;
	imgsensor.frame_length = imgsensor_info.normal_video.framelength;
	imgsensor.min_frame_length = imgsensor_info.normal_video.framelength;
	/*imgsensor.current_fps = 300;*/
	imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	normal_video_setting();
	return ERROR_NONE;
}	/* normal_video */

static kal_uint32 hs_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
		MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E");

	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_HIGH_SPEED_VIDEO;
	imgsensor.pclk = imgsensor_info.hs_video.pclk;
	/*imgsensor.video_mode = KAL_TRUE;*/
	imgsensor.line_length = imgsensor_info.hs_video.linelength;
	imgsensor.frame_length = imgsensor_info.hs_video.framelength;
	imgsensor.min_frame_length = imgsensor_info.hs_video.framelength;
	imgsensor.dummy_line = 0;
	imgsensor.dummy_pixel = 0;
	imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	hs_video_setting();
	return ERROR_NONE;
}	/* hs_video */

static kal_uint32 slim_video(MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
		MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("E");
	spin_lock(&imgsensor_drv_lock);
	imgsensor.sensor_mode = IMGSENSOR_MODE_SLIM_VIDEO;
	imgsensor.pclk = imgsensor_info.slim_video.pclk;
	imgsensor.line_length = imgsensor_info.slim_video.linelength;
	imgsensor.frame_length = imgsensor_info.slim_video.framelength;
	imgsensor.min_frame_length = imgsensor_info.slim_video.framelength;
	imgsensor.dummy_line = 0;
	imgsensor.dummy_pixel = 0;
	imgsensor.autoflicker_en = KAL_FALSE;
	spin_unlock(&imgsensor_drv_lock);
	slim_video_setting();
	return ERROR_NONE;
}

static kal_uint32 get_resolution(
	MSDK_SENSOR_RESOLUTION_INFO_STRUCT(*sensor_resolution))
{
	LOG_INF("E");
	sensor_resolution->SensorFullWidth =
		imgsensor_info.cap.grabwindow_width;
	sensor_resolution->SensorFullHeight =
		imgsensor_info.cap.grabwindow_height;

	sensor_resolution->SensorPreviewWidth =
		imgsensor_info.pre.grabwindow_width;
	sensor_resolution->SensorPreviewHeight =
		imgsensor_info.pre.grabwindow_height;

	sensor_resolution->SensorVideoWidth =
		imgsensor_info.normal_video.grabwindow_width;
	sensor_resolution->SensorVideoHeight =
		imgsensor_info.normal_video.grabwindow_height;

	sensor_resolution->SensorHighSpeedVideoWidth =
		imgsensor_info.hs_video.grabwindow_width;
	sensor_resolution->SensorHighSpeedVideoHeight =
		imgsensor_info.hs_video.grabwindow_height;

	sensor_resolution->SensorSlimVideoWidth =
		imgsensor_info.slim_video.grabwindow_width;
	sensor_resolution->SensorSlimVideoHeight =
		imgsensor_info.slim_video.grabwindow_height;
	return ERROR_NONE;
}

static kal_uint32 get_info(enum MSDK_SCENARIO_ID_ENUM scenario_id,
			MSDK_SENSOR_INFO_STRUCT *sensor_info,
			MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("scenario_id = %d", scenario_id);
	sensor_info->SensorClockPolarity = SENSOR_CLOCK_POLARITY_LOW;
	/* not use */
	sensor_info->SensorClockFallingPolarity = SENSOR_CLOCK_POLARITY_LOW;
	/* inverse with datasheet */
	sensor_info->SensorHsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
	sensor_info->SensorVsyncPolarity = SENSOR_CLOCK_POLARITY_LOW;
	sensor_info->SensorInterruptDelayLines = 4; /* not use */
	sensor_info->SensorResetActiveHigh = FALSE; /* not use */
	sensor_info->SensorResetDelayCount = 5; /* not use */

	sensor_info->SensroInterfaceType = imgsensor_info.sensor_interface_type;
	sensor_info->MIPIsensorType = imgsensor_info.mipi_sensor_type;
	sensor_info->SettleDelayMode = imgsensor_info.mipi_settle_delay_mode;
	sensor_info->SensorOutputDataFormat =
			imgsensor_info.sensor_output_dataformat;

	sensor_info->CaptureDelayFrame = imgsensor_info.cap_delay_frame;
	sensor_info->PreviewDelayFrame = imgsensor_info.pre_delay_frame;
	sensor_info->VideoDelayFrame = imgsensor_info.video_delay_frame;
	sensor_info->HighSpeedVideoDelayFrame =
			imgsensor_info.hs_video_delay_frame;
	sensor_info->SlimVideoDelayFrame =
			imgsensor_info.slim_video_delay_frame;
	sensor_info->SlimVideoDelayFrame =
			imgsensor_info.slim_video_delay_frame;

	sensor_info->SensorMasterClockSwitch = 0; /* not use */
	sensor_info->SensorDrivingCurrent = imgsensor_info.isp_driving_current;

	sensor_info->YUVAwbDelayFrame = imgsensor_info.awb_delay_frame;
	sensor_info->YUVEffectDelayFrame = imgsensor_info.effect_delay_frame;
	sensor_info->AEShutDelayFrame = imgsensor_info.ae_delay_frame;

	/* The frame of setting shutter default 0 for TG int */
	sensor_info->AEShutDelayFrame = imgsensor_info.ae_shut_delay_frame;
	/* The frame of setting sensor gain */
	sensor_info->AESensorGainDelayFrame =
			imgsensor_info.ae_sensor_gain_delay_frame;
	sensor_info->AEISPGainDelayFrame =
			imgsensor_info.ae_ispGain_delay_frame;
	sensor_info->IHDR_Support = imgsensor_info.ihdr_support;
	sensor_info->IHDR_LE_FirstLine = imgsensor_info.ihdr_le_firstline;
	sensor_info->SensorModeNum = imgsensor_info.sensor_mode_num;

	sensor_info->SensorMIPILaneNumber = imgsensor_info.mipi_lane_num;
	sensor_info->SensorClockFreq = imgsensor_info.mclk;
	sensor_info->SensorClockDividCount = 3; /* not use */
	sensor_info->SensorClockRisingCount = 0;
	sensor_info->SensorClockFallingCount = 2; /* not use */
	sensor_info->SensorPixelClockCount = 3; /* not use */
	sensor_info->SensorDataLatchCount = 2; /* not use */

	sensor_info->MIPIDataLowPwr2HighSpeedTermDelayCount = 0;
	sensor_info->MIPICLKLowPwr2HighSpeedTermDelayCount = 0;
	sensor_info->SensorWidthSampling = 0; /* 0 is default 1x */
	sensor_info->SensorHightSampling = 0; /*0 is default 1x */
	sensor_info->SensorPacketECCOrder = 1;

	switch (scenario_id) {
	case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
		sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
		sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
		sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount
			= imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
		break;
	case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
		sensor_info->SensorGrabStartX = imgsensor_info.cap.startx;
		sensor_info->SensorGrabStartY = imgsensor_info.cap.starty;
		sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount
			= imgsensor_info.cap.mipi_data_lp2hs_settle_dc;
		break;
	case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
		sensor_info->SensorGrabStartX =
				imgsensor_info.normal_video.startx;
		sensor_info->SensorGrabStartY =
				imgsensor_info.normal_video.starty;
		sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount
			= imgsensor_info.normal_video.mipi_data_lp2hs_settle_dc;
		break;
	case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
		sensor_info->SensorGrabStartX = imgsensor_info.hs_video.startx;
		sensor_info->SensorGrabStartY = imgsensor_info.hs_video.starty;
		sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount
			= imgsensor_info.hs_video.mipi_data_lp2hs_settle_dc;
		break;
	case MSDK_SCENARIO_ID_SLIM_VIDEO:
		sensor_info->SensorGrabStartX =
				imgsensor_info.slim_video.startx;
		sensor_info->SensorGrabStartY =
				imgsensor_info.slim_video.starty;
		sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount
			= imgsensor_info.slim_video.mipi_data_lp2hs_settle_dc;
		break;
	default:
		sensor_info->SensorGrabStartX = imgsensor_info.pre.startx;
		sensor_info->SensorGrabStartY = imgsensor_info.pre.starty;
		sensor_info->MIPIDataLowPwr2HighSpeedSettleDelayCount
			= imgsensor_info.pre.mipi_data_lp2hs_settle_dc;
		break;
	}
	return ERROR_NONE;
}

static kal_uint32 control(enum MSDK_SCENARIO_ID_ENUM scenario_id,
	MSDK_SENSOR_EXPOSURE_WINDOW_STRUCT *image_window,
	MSDK_SENSOR_CONFIG_STRUCT *sensor_config_data)
{
	LOG_INF("scenario_id = %d", scenario_id);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.current_scenario_id = scenario_id;
	spin_unlock(&imgsensor_drv_lock);
	switch (scenario_id) {
	case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
		preview(image_window, sensor_config_data);
		break;
	case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
		capture(image_window, sensor_config_data);
		break;
	case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
		normal_video(image_window, sensor_config_data);
		break;
	case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
		hs_video(image_window, sensor_config_data);
		break;
	case MSDK_SCENARIO_ID_SLIM_VIDEO:
		slim_video(image_window, sensor_config_data);
		break;
	default:
		LOG_INF("Error ScenarioId setting");
		preview(image_window, sensor_config_data);
		return ERROR_INVALID_SCENARIO_ID;
	}
	return ERROR_NONE;
}

#if 0
static void awb_calibattion(kal_uint32 color_r_gain, kal_uint32 color_b_gain)
{
	kal_uint32 color_r_gain_w = 0;
	kal_uint32 color_b_gain_w = 0;
	kal_uint8 interval = 0;

	LOG_INF("E\n");
	interval = read_cmos_sensor(0x350b);
	if (color_r_gain > 0x600) { /* d65   66b 5a7 4a7 449 */
		if (interval >= 0x70) {
			color_r_gain_w = color_r_gain * 95/100;
			color_b_gain_w = color_b_gain * 97/100;
		} else if (interval >= 0x58) {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 98/100;
		} else if (interval >= 0x48) {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 98/100;
		} else if (interval >= 0x30) {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 98/100;
		} else {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 98/100;
		}
	} else if (color_r_gain > 0x540) { /* cwf */
		if (interval >= 0x70) {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 98/100;
		} else if (interval >= 0x58) {
			color_r_gain_w = color_r_gain * 98/100;
			color_b_gain_w = color_b_gain * 99/100;
		} else if (interval >= 0x48) {
			color_r_gain_w = color_r_gain * 98/100;
			color_b_gain_w = color_b_gain * 99/100;
		} else if (interval >= 0x30) {
			color_r_gain_w = color_r_gain * 99/100;
			color_b_gain_w = color_b_gain * 99/100;
		} else {
			color_r_gain_w = color_r_gain * 99/100;
			color_b_gain_w = color_b_gain * 99/100;
		}
	} else if (color_r_gain > 0x480) { /* tl84 */
		if (interval >= 0x70) {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 97/100;
		} else if (interval >= 0x58) {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 97/100;
		} else if (interval >= 0x48) {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 97/100;
		} else if (interval >= 0x30) {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 97/100;
		} else {
			color_r_gain_w = color_r_gain * 97/100;
			color_b_gain_w = color_b_gain * 97/100;
		}
	} else { /* h/a */
		if (interval >= 0x70) {
			color_r_gain_w = color_r_gain * 98/100;
			color_b_gain_w = color_b_gain * 97/100;
		} else if (interval >= 0x58) {
			color_r_gain_w = color_r_gain * 98/100;
			color_b_gain_w = color_b_gain * 97/100;
		} else if (interval >= 0x48) {
			color_r_gain_w = color_r_gain * 98/100;
			color_b_gain_w = color_b_gain * 97/100;
		} else if (interval >= 0x30) {
			color_r_gain_w = color_r_gain * 98/100;
			color_b_gain_w = color_b_gain * 97/100;
		} else {
			color_r_gain_w = color_r_gain * 98/100;
			color_b_gain_w = color_b_gain * 97/100;
		}
	}

	write_cmos_sensor(0x3400, (color_r_gain_w & 0xff00)>>8);
	write_cmos_sensor(0x3401, color_r_gain_w & 0xff);
	write_cmos_sensor(0x3404, (color_b_gain_w & 0xff00)>>8);
	write_cmos_sensor(0x3405, color_b_gain_w & 0xff);
}
#endif

static void get_evawb_ref(uintptr_t pSensorAEAWBRefStruct)
{
	struct SENSOR_AE_AWB_REF_STRUCT *Ref =
		(struct SENSOR_AE_AWB_REF_STRUCT *)
		(uintptr_t) pSensorAEAWBRefStruct;

	LOG_INF("E\n");
	Ref->SensorAERef.AeRefLV05Shutter = 0x170c;
	Ref->SensorAERef.AeRefLV05Gain = 0x30;
	Ref->SensorAERef.AeRefLV13Shutter = 0x24e;
	Ref->SensorAERef.AeRefLV13Gain = 0x10;
	Ref->SensorAwbGainRef.AwbRefD65Rgain = 0x610;
	Ref->SensorAwbGainRef.AwbRefD65Bgain = 0x448;
	Ref->SensorAwbGainRef.AwbRefCWFRgain = 0x4e0;
	Ref->SensorAwbGainRef.AwbRefCWFBgain = 0x5a0;
}

static void get_curaeawb_Info(uintptr_t pSensorAEAWBCurStruct)
{
	struct SENSOR_AE_AWB_CUR_STRUCT *Info =
		(struct SENSOR_AE_AWB_CUR_STRUCT *) pSensorAEAWBCurStruct;

	LOG_INF("E\n");
	Info->SensorAECur.AeCurShutter = get_shutter();
	Info->SensorAECur.AeCurGain = get_gain();
	Info->SensorAwbGainCur.AwbCurRgain
		= ((read_cmos_sensor(0x3401) & 0xff) +
			((read_cmos_sensor(0x3400) & 0xff)*256));
	Info->SensorAwbGainCur.AwbCurBgain
		= ((read_cmos_sensor(0x3405) & 0xff) +
			((read_cmos_sensor(0x3404) & 0xff)*256));

	LOG_INF("L\n");
}
static kal_uint32 get_default_framerate_by_scenario(
		enum MSDK_SCENARIO_ID_ENUM scenario_id, MUINT32 *framerate)
{
	LOG_INF("scenario_id = %d\n", scenario_id);
	switch (scenario_id) {
	case MSDK_SCENARIO_ID_CAMERA_PREVIEW:
		*framerate = imgsensor_info.pre.max_framerate;
		break;
	case MSDK_SCENARIO_ID_VIDEO_PREVIEW:
		*framerate = imgsensor_info.normal_video.max_framerate;
		break;
	case MSDK_SCENARIO_ID_CAMERA_CAPTURE_JPEG:
		*framerate = imgsensor_info.cap.max_framerate;
		break;
	case MSDK_SCENARIO_ID_HIGH_SPEED_VIDEO:
		*framerate = imgsensor_info.hs_video.max_framerate;
		break;
	case MSDK_SCENARIO_ID_SLIM_VIDEO:
		*framerate = imgsensor_info.slim_video.max_framerate;
		break;
	default:
		*framerate = imgsensor_info.pre.max_framerate;
		break;
	}
	LOG_INF("L! framerate = %d\n", *framerate);
	return ERROR_NONE;
}

static void get_aeawb_lock_info(UINT32 *pAElockRet32, UINT32 *pAWBlockRet32)
{
	*pAElockRet32 = 1;
	*pAWBlockRet32 = 1;
	LOG_INF("pAElockRet32 = %d,pAWBlockRet32=%d\n",
			*pAElockRet32, *pAWBlockRet32);
}
static void get_delay_Info(uintptr_t delayAddr)
{
	struct SENSOR_DELAY_INFO_STRUCT *pDelayInfo =
			(struct SENSOR_DELAY_INFO_STRUCT *)delayAddr;

	LOG_INF("E\n");
	pDelayInfo->InitDelay = imgsensor_info.InitDelay;
	pDelayInfo->EffectDelay = imgsensor_info.EffectDelay;
	pDelayInfo->AwbDelay = imgsensor_info.AwbDelay;
	pDelayInfo->AFSwitchDelayFrame = imgsensor_info.AFSwitchDelayFrame;
}
static void set_flashtrigger_info(unsigned int *pFeatureReturnPara32)
{
	unsigned int NormBr;

	LOG_INF("E\n");
	NormBr = read_cmos_sensor(0x56A1);
	if (NormBr > imgsensor_info.flash_bv_threshold)
		*pFeatureReturnPara32 = FALSE;
	else
		*pFeatureReturnPara32 = TRUE;
	LOG_INF("L! r:%d\n", *pFeatureReturnPara32);
}

static void get_flash_Info(uintptr_t infoAddr)
{
	struct SENSOR_FLASHLIGHT_AE_INFO_STRUCT *pAeInfo =
			(struct SENSOR_FLASHLIGHT_AE_INFO_STRUCT *)infoAddr;

	pAeInfo->Exposuretime = get_shutter();
	pAeInfo->Gain = get_gain();
	pAeInfo->u4Fno = imgsensor.FNumber;
	pAeInfo->GAIN_BASE = 0x100;
}
static kal_uint32 set_test_pattern_mode(kal_bool enable)
{
	LOG_INF("enable: %d\n", enable);
	if (enable)
		write_cmos_sensor(0x503d, 0x80);
	else
		write_cmos_sensor(0x503d, 0x00);
	spin_lock(&imgsensor_drv_lock);
	imgsensor.test_pattern = enable;
	spin_unlock(&imgsensor_drv_lock);
	return ERROR_NONE;
}
static void af_Init(void)
{
	LOG_INF("E\n");
	write_cmos_sensor(0x3000, 0x20);
	iBurstWriteReg(addr_data_pair1, 254, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair2, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair3, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair4, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair5, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair6, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair7, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair8, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair9, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair10, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair11, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair12, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair13, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair14, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair15, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair16, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair17, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair18, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair19, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair20, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair21, 255, imgsensor.i2c_write_id);
	iBurstWriteReg(addr_data_pair22, 181, imgsensor.i2c_write_id);
	write_cmos_sensor(0x3022, 0x00);
	write_cmos_sensor(0x3023, 0x00);
	write_cmos_sensor(0x3024, 0x00);
	write_cmos_sensor(0x3025, 0x00);
	write_cmos_sensor(0x3026, 0x00);
	write_cmos_sensor(0x3027, 0x00);
	write_cmos_sensor(0x3028, 0x00);
	write_cmos_sensor(0x3029, 0x7F);
	write_cmos_sensor(0x3000, 0x00);
}

static void constant_af(void)
{
	LOG_INF("E\n");
	write_cmos_sensor(0x3023, 0x01);
	write_cmos_sensor(0x3022, 0x80);
	mDELAY(10);
	write_cmos_sensor(0x3023, 0x01);
	write_cmos_sensor(0x3022, 0x04);
}
static void single_af(void)
{
	write_cmos_sensor(0x3023, 0x01);
	write_cmos_sensor(0x3022, 0x06);
	write_cmos_sensor(0x3023, 0x01);
	write_cmos_sensor(0x3022, 0x81);
	mDELAY(10);
	write_cmos_sensor(0x3023, 0x01);
	write_cmos_sensor(0x3022, 0x03);
}

static void get_af_max_num_focus_areas(UINT32 *pFeatureReturnPara32)
{
	*pFeatureReturnPara32 = 1;
	/* 0 is means it is not support touch af,
	 * 1 is means it is support touch af
	 */
}

static void get_ae_max_num_metering_areas(UINT32 *pFeatureReturnPara32)
{
	*pFeatureReturnPara32 = 1;
	/* 0 is means it is not support touch ae,
	 * 1 is means it is support touch ae
	 */
}
static void set_preview_coordinate_to_sensor_coordinate(
		unsigned int prevX, unsigned int prevY)
{
	unsigned int prevX_cur;
	unsigned int prevY_cur;

	LOG_INF("E:\n");
	prevX_cur = prevX/16;
	prevY_cur = prevY/16;
	if (prevX_cur < 1)
		imgsensor.af_coordinate_x = 1;
	else if (prevX_cur > 79)
		imgsensor.af_coordinate_x = 79;
	else
		imgsensor.af_coordinate_x = prevX_cur;
	if (prevY_cur < 1)
		imgsensor.af_coordinate_y = 1;
	else if (prevY_cur > 59)
		imgsensor.af_coordinate_y = 59;
	else
		imgsensor.af_coordinate_y = prevY_cur;
}
static void set_sensor_coordinate_to_register(
		unsigned int prevX, unsigned int prevY)
{
	write_cmos_sensor(0x3024, prevX);
	write_cmos_sensor(0x3025, prevY);
	mDELAY(10);
}
static void set_af_window(uintptr_t zone_addr,
		unsigned int prevW, unsigned int prevH)
{
	/* update global zone */
	unsigned int src_x_size;
	unsigned int src_y_size;
	unsigned int x0, y0, x1, y1;
	unsigned int srcW_maxW;
	unsigned int srcW_maxH;
	UINT32 *zone = (UINT32 *)zone_addr;

	LOG_INF("E\n");
	x0 = *zone;
	y0 = *(zone + 1);
	x1 = *(zone + 2);
	y1 = *(zone + 3);
	src_x_size = *(zone + 4);
	src_y_size = *(zone + 5);
	/* src_x_size=320,src_y_size=240;CAF:x0=x1,y0=y1; */
	if (src_x_size == 0)
		src_x_size = 320;

	if (src_y_size == 0)
		src_y_size = 240;

	if (src_x_size > prevW)
		src_x_size = prevW;

	if (src_y_size > prevH)
		src_y_size = prevH;

	srcW_maxW = src_x_size;
	srcW_maxH = src_y_size;
	if (x0 >= srcW_maxW)
		x0 = srcW_maxW - 1;

	if (x1 >= srcW_maxW)
		x1 = srcW_maxW - 1;

	if (y0 >= srcW_maxH)
		y0 = srcW_maxH - 1;

	if (y1 >= srcW_maxH)
		y1 = srcW_maxH - 1;
	LOG_INF("AE x0=%d,y0=%d,x1=%d,y1=%d,src_x_size=%d,src_y_size=%d\n"
		, x0, y0, x1, y1, src_x_size, src_y_size);
	if ((x0 == x1) && (y0 == y1)) { /* CAF not update window */
		if (imgsensor.caf_flag == KAL_TRUE)
			return;

		imgsensor.caf_flag = KAL_TRUE;
		imgsensor.af_coordinate_x = 0;
		imgsensor.af_coordinate_y = 0;
	} else {
		imgsensor.caf_flag = KAL_FALSE;
		x0 = (x0 + x1) / 2;
		y0 = (y0 + y1) / 2;
		/* Map 320x240 coordinate to preview size window */
		x0 = x0 * (prevW / srcW_maxW);
		y0 = y0 * (prevH / srcW_maxH);
		/* FD AF MODE,if window change less than 100 pixel,
		 * AF wimdow not update!
		 */
		if ((x0 >= imgsensor.af_coordinate_x+100) ||
		    (x0+100 <= imgsensor.af_coordinate_x) ||
		    (y0+100 <= imgsensor.af_coordinate_y) ||
		    (y0 >= imgsensor.af_coordinate_y+100))
			return;
		/* Map preview size window coordinate to sensor af coordinate */
		set_preview_coordinate_to_sensor_coordinate(x0, y0);
	}
	set_sensor_coordinate_to_register(
		imgsensor.af_coordinate_x, imgsensor.af_coordinate_y);
}

static void get_af_macro(UINT32 *pFeatureReturnPara32)
{
	*pFeatureReturnPara32 = 0;
}
static void get_af_Inf(UINT32 *pFeatureReturnPara32)
{
	*pFeatureReturnPara32 = 0;
}
static void get_af_status(UINT32 *pFeatureReturnPara32)
{
	UINT32 state_3029 = 0;

	LOG_INF("E\n");
	state_3029 = read_cmos_sensor(0x3029);
	switch (state_3029) {
	case 0x70:
		*pFeatureReturnPara32 = SENSOR_AF_IDLE;
		break;
	case 0x00:
		*pFeatureReturnPara32 = SENSOR_AF_FOCUSING;
		break;
	case 0x10:
		*pFeatureReturnPara32 = SENSOR_AF_FOCUSED;
		break;
	case 0x20:
		*pFeatureReturnPara32 = SENSOR_AF_FOCUSED;
		break;
	default:
		*pFeatureReturnPara32 = SENSOR_AF_SCENE_DETECTING;
		break;
	}
		LOG_INF("bk_ L! state_3029 = %d\n", state_3029);
}
static void cancel_af(void)
{
	write_cmos_sensor(0x3023, 0x01);
	write_cmos_sensor(0x3022, 0x08);
}
static void init_ae_table(unsigned int win_w, unsigned int win_h)
{
	unsigned int i, j;

	LOG_INF("E\n win_w=%d,win_h=%d", win_w, win_h);
	for (i = 0; i < AE_WIN_MUN_W; i++)
		ae_win_w[i] = win_w*(i+1);

	for (j = 0; j < AE_WIN_MUN_H; j++)
		ae_win_h[j] = win_h*(j+1);

	for (j = 0; j < AE_WIN_MUN_H; j++) {
		for (i = 0; i < AE_WIN_MUN_W; i++)
			ae_pline_table[j][i] = FALSE;
	}
}
static void set_ae_block(unsigned int x0, unsigned int y0)
{
	unsigned int i, j;

	LOG_INF("E! x0=%d, y0=%d\n", x0, y0);
	for (i = 0; i < AE_WIN_MUN_W; i++) {
		if (x0 <= ae_win_w[i])
			break;
	}
	for (j = 0; j < AE_WIN_MUN_H; j++) {
		if (y0 <= ae_win_h[j])
			break;
	}
	ae_pline_table[j][i] = TRUE;
}
static void write_ae_reg(void)
{
	UINT8 temp;
	/* write 1280X960 */
	write_cmos_sensor(0x501d, 0x10);
	write_cmos_sensor(0x5680, 0x00);
	write_cmos_sensor(0x5681, 0x00);
	write_cmos_sensor(0x5682, 0x00);
	write_cmos_sensor(0x5683, 0x00);
	write_cmos_sensor(0x5684, 0x05); /* width=256 */
	write_cmos_sensor(0x5685, 0x00);
	write_cmos_sensor(0x5686, 0x03); /* heght=256 */
	write_cmos_sensor(0x5687, 0xc0);
	temp = 0x11;
	if (ae_pline_table[0][0] == TRUE)
		temp = temp|0x0F;
	if (ae_pline_table[0][1] == TRUE)
		temp = temp|0xF0;
	/* write 0x5688 */
	write_cmos_sensor(0x5688, temp);
	temp = 0x11;
	if (ae_pline_table[0][2] == TRUE)
		temp = temp|0x0F;
	if (ae_pline_table[0][3] == TRUE)
		temp = temp|0xF0;
	/* write 0x5689 */
	write_cmos_sensor(0x5689, temp);
	temp = 0x11;
	if (ae_pline_table[1][0] == TRUE)
		temp = temp|0x0F;
	if (ae_pline_table[1][1] == TRUE)
		temp = temp|0xF0;
	/* write 0x568A */
	write_cmos_sensor(0x568A, temp);
	temp = 0x11;
	if (ae_pline_table[1][2] == TRUE)
		temp = temp|0x0F;
	if (ae_pline_table[1][3] == TRUE)
		temp = temp|0xF0;
	/* write 0x568B */
	write_cmos_sensor(0x568B, temp);
	temp = 0x11;
	if (ae_pline_table[2][0] == TRUE)
		temp = temp|0x0F;
	if (ae_pline_table[2][1] == TRUE)
		temp = temp|0xF0;
	/* write 0x568C */
	write_cmos_sensor(0x568C, temp);
	temp = 0x11;
	if (ae_pline_table[2][2] == TRUE)
		temp = temp|0x0F;
	if (ae_pline_table[2][3] == TRUE)
		temp = temp|0xF0;
	/* write 0x568D */
	write_cmos_sensor(0x568D, temp);
	temp = 0x11;
	if (ae_pline_table[3][0] == TRUE)
		temp = temp|0x0F;
	if (ae_pline_table[3][1] == TRUE)
		temp = temp|0xF0;
	/* write 0x568E */
	write_cmos_sensor(0x568E, temp);
	temp = 0x11;
	if (ae_pline_table[3][2] == TRUE)
		temp = temp|0x0F;
	if (ae_pline_table[3][3] == TRUE)
		temp = temp|0xF0;
	/* write 0x568F */
	write_cmos_sensor(0x568F, temp);
}
static void print_ae_planetable(void)
{
	unsigned int i, j;

	for (i = 0; i < AE_WIN_MUN_W; i++)
		LOG_INF("ae_win_w=%d,i=%d", ae_win_w[i], i);

	for (j = 0; j < AE_WIN_MUN_H; j++)
		LOG_INF("ae_win_h=%d,j=%d", ae_win_h[j], j);

	for (j = 0; j < AE_WIN_MUN_H; j++) {
		for (i = 0; i < AE_WIN_MUN_W; i++) {
			LOG_INF("ae_pline_table=%d, i=%d, j=%d",
				ae_pline_table[j][i], i, j);
		}
	}
}

static void set_ae_window(
	uintptr_t zone_addr, unsigned int prevW, unsigned int prevH)
{
	unsigned int src_x_size;
	unsigned int src_y_size;
	unsigned int x0, y0, x1, y1;
	unsigned int srcW_maxW;
	unsigned int srcW_maxH;
	unsigned int win_W, win_H;
	/*unsigned char ae_table[8][8];*/
	UINT32 *zone = (UINT32 *)zone_addr;

	LOG_INF("E:\n");
	x0 = *zone;
	y0 = *(zone + 1);
	x1 = *(zone + 2);
	y1 = *(zone + 3);
	src_x_size = *(zone + 4);
	src_y_size = *(zone + 5);

	/* src_x_size=320,src_y_size=240;CAF:x0=x1,y0=y1; */
	if (src_x_size == 0)
		src_x_size = 320;

	if (src_y_size == 0)
		src_y_size = 240;

	if (src_x_size > prevW)
		src_x_size = prevW;

	if (src_y_size > prevH)
		src_y_size = prevH;

	LOG_INF("AE x0=%d, y0=%d, x1=%d, y1=%d, src_x_size=%d, src_y_size=%d\n",
		x0, y0, x1, y1, src_x_size, src_y_size);
	if ((x0 == x1) && (y0 == y1)) /* CAF not update window */
		return;
	srcW_maxW = src_x_size;
	srcW_maxH = src_y_size;
	if (x0 >= srcW_maxW)
		x0 = srcW_maxW - 1;

	if (x1 >= srcW_maxW)
		x1 = srcW_maxW - 1;

	if (y0 >= srcW_maxH)
		y0 = srcW_maxH - 1;

	if (y1 >= srcW_maxH)
		y1 = srcW_maxH - 1;

	/* Map 320x240 coordinate to preview size window */
	x0 = x0 * (prevW / srcW_maxW);
	y0 = y0 * (prevH / srcW_maxH);
	x1 = x1 * (prevW / srcW_maxW);
	y1 = y1 * (prevH / srcW_maxH);
	x0 = (x0+x1)/2;
	y0 = (y0+y1)/2;
	/* preview size window divide to 4*4 block */
	win_W = prevW/4;
	win_H = prevH/4;
	init_ae_table(win_W, win_H);
	set_ae_block(x0, y0);
	print_ae_planetable();
	write_ae_reg();
}

#ifdef USE_STREAM
static kal_uint32 streaming_control(kal_bool enable)
{
	LOG_INF("streaming_enable(0=Sw Standby,1=streaming): %d\n", enable);
	if (enable) {
		/*0x3008[6] = 0*/
		write_cmos_sensor(0x3008, 0x02);
	} else {
		write_cmos_sensor(0x3103, 0x11);
		write_cmos_sensor(0x3008, 0x82);/* Reset = 1*/
		write_cmos_sensor(0x3008, 0x42);/*0x3008[6] = 1*/
	}
	return ERROR_NONE;
}
#endif
static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,
			UINT8 *feature_para, UINT32 *feature_para_len)
{
	UINT16 *feature_return_para_16 = (UINT16 *) feature_para;
	UINT32 *feature_return_para_32 = (UINT32 *) feature_para;
	UINT32 *feature_data_32 = (UINT32 *) feature_para;
	unsigned long long *feature_data = (unsigned long long *)feature_para;
	/*SENSOR_WINSIZE_INFO_STRUCT *wininfo;*/
	MSDK_SENSOR_REG_INFO_STRUCT *sensor_reg_data =
		(MSDK_SENSOR_REG_INFO_STRUCT *) feature_para;

	LOG_INF("feature_id = %d", feature_id);
	switch (feature_id) {
	case SENSOR_FEATURE_GET_PERIOD:
		*feature_return_para_16++ = imgsensor.line_length;
		*feature_return_para_16 = imgsensor.frame_length;
		*feature_para_len = 4;
		break;
	case SENSOR_FEATURE_GET_PIXEL_CLOCK_FREQ:
	LOG_INF(
	  "feature_Control imgsensor.pclk = %d,imgsensor.current_fps = %d\n"
	  , imgsensor.pclk, imgsensor.current_fps);
	*feature_return_para_32 = imgsensor.pclk;
	*feature_para_len = 4;
		break;
	case SENSOR_FEATURE_SET_NIGHTMODE:
		set_scenemode_night();
		break;
	case SENSOR_FEATURE_SET_MIN_MAX_FPS:
		set_max_min_fps((UINT32) *feature_data,
			(UINT32) *(feature_data+1));
		break;
	/**********************Strobe Ctrl Start *****************************/
	case SENSOR_FEATURE_SET_ESHUTTER:
		set_shutter(*feature_data);
		break;
	case SENSOR_FEATURE_SET_GAIN:
		set_gain(*feature_data);
		break;
	case SENSOR_FEATURE_GET_AE_FLASHLIGHT_INFO:
		get_flash_Info((uintptr_t) *feature_data);
		break;
	case SENSOR_FEATURE_GET_TRIGGER_FLASHLIGHT_INFO:
		set_flashtrigger_info(feature_data_32);
		break;
	case SENSOR_FEATURE_SET_FLASHLIGHT:
		break;
	/**********************Strobe Ctrl End *******************************/
	case SENSOR_FEATURE_SET_ISP_MASTER_CLOCK_FREQ:
		break;
	case SENSOR_FEATURE_SET_REGISTER:
		if ((sensor_reg_data->RegData>>8) > 0)
			write_cmos_sensor(sensor_reg_data->RegAddr,
				sensor_reg_data->RegData);
		else
			write_cmos_sensor(sensor_reg_data->RegAddr,
				sensor_reg_data->RegData);
		break;
	case SENSOR_FEATURE_GET_REGISTER:
		sensor_reg_data->RegData =
			read_cmos_sensor(sensor_reg_data->RegAddr);
		break;
	case SENSOR_FEATURE_GET_LENS_DRIVER_ID:
		*feature_return_para_32 = LENS_DRIVER_ID_DO_NOT_CARE;
		*feature_para_len = 4;
		break;
	case SENSOR_FEATURE_SET_YUV_CMD:
		set_yuv_cmd((enum FEATURE_ID)*feature_data, *(feature_data+1));
		break;
	case SENSOR_FEATURE_SET_YUV_3A_CMD:
		set_3actrl_info((enum ACDK_SENSOR_3A_LOCK_ENUM)*feature_data);
		break;
	case SENSOR_FEATURE_SET_VIDEO_MODE:
		set_video_mode(*feature_data);
		break;
	case SENSOR_FEATURE_CHECK_SENSOR_ID:
		get_imgsensor_id(feature_return_para_32);
		break;
	case SENSOR_FEATURE_GET_EV_AWB_REF:
		get_evawb_ref((uintptr_t)*feature_data);
		break;
	case SENSOR_FEATURE_GET_SHUTTER_GAIN_AWB_GAIN:
		get_curaeawb_Info(*feature_data);
		break;
	case SENSOR_FEATURE_GET_EXIF_INFO:
		get_exifInfo((uintptr_t)*feature_data);
		break;
	case SENSOR_FEATURE_GET_DELAY_INFO:
		get_delay_Info((uintptr_t) *feature_data);
		break;
	case SENSOR_FEATURE_SET_TEST_PATTERN:
		set_test_pattern_mode((BOOL) *feature_data);
		break;
	case SENSOR_FEATURE_GET_TEST_PATTERN_CHECKSUM_VALUE:
		*feature_return_para_32 = imgsensor_info.checksum_value;
		*feature_para_len = 4;
		break;
	case SENSOR_FEATURE_SET_MAX_FRAME_RATE_BY_SCENARIO:
		break;
	case SENSOR_FEATURE_GET_DEFAULT_FRAME_RATE_BY_SCENARIO:
		get_default_framerate_by_scenario(
			(enum MSDK_SCENARIO_ID_ENUM) *feature_data,
			(MUINT32 *) (uintptr_t) (*(feature_data + 1)));
		break;
	/******************AF control below*********************/
	case SENSOR_FEATURE_INITIALIZE_AF:
		af_Init();
		break;
	case SENSOR_FEATURE_MOVE_FOCUS_LENS:
		/*af_move_to(feature_data_32);*/ /* ot implement yet. */
		break;
	case SENSOR_FEATURE_GET_AF_STATUS:
		get_af_status(feature_data_32);
		*feature_para_len = 4;
		break;
	case SENSOR_FEATURE_SINGLE_FOCUS_MODE:
		single_af();
		break;
	case SENSOR_FEATURE_CONSTANT_AF:
		constant_af();
		break;
	case SENSOR_FEATURE_CANCEL_AF:
		cancel_af();
		break;
	case SENSOR_FEATURE_GET_AF_INF:
		get_af_Inf(feature_data_32);
		*feature_para_len = 4;
		break;
	case SENSOR_FEATURE_GET_AF_MACRO:
		get_af_macro(feature_data_32);
		*feature_para_len = 4;
		break;
	case SENSOR_FEATURE_GET_AF_MAX_NUM_FOCUS_AREAS:

		get_af_max_num_focus_areas(feature_data_32);
		*feature_para_len = 4;
		break;
	case SENSOR_FEATURE_GET_AE_MAX_NUM_METERING_AREAS:
		get_ae_max_num_metering_areas(feature_data_32);
		*feature_para_len = 4;
		break;
	case SENSOR_FEATURE_SET_AF_WINDOW:
		set_af_window((uintptr_t) *feature_data,
			imgsensor_info.pre.grabwindow_width,
			imgsensor_info.pre.grabwindow_height);
		break;
	case SENSOR_FEATURE_SET_AE_WINDOW:
		set_ae_window((uintptr_t) *feature_data,
			imgsensor_info.pre.grabwindow_width,
			imgsensor_info.pre.grabwindow_height);
		break;
		break;
	case SENSOR_FEATURE_GET_AE_AWB_LOCK_INFO:
		get_aeawb_lock_info((MUINT32 *)(uintptr_t)(*feature_data),
			(MUINT32 *)(uintptr_t)(*(feature_data + 1)));
		break;
#ifdef USE_STREAM
	case SENSOR_FEATURE_SET_STREAMING_SUSPEND:
		LOG_INF("SENSOR_FEATURE_SET_STREAMING_SUSPEND\n");
		streaming_control(KAL_FALSE);
		break;
	case SENSOR_FEATURE_SET_STREAMING_RESUME:
		LOG_INF("SENSOR_FEATURE_SET_STREAMING_RESUME\n");
		streaming_control(KAL_TRUE);
		break;
#endif
	default:
		break;
	}
	return ERROR_NONE;
}	/* OV5645MIPIFeatureControl() */

static struct SENSOR_FUNCTION_STRUCT SensorFuncOV5645MIPI = {
	open,
	get_info,
	get_resolution,
	feature_control,
	control,
	close
};

UINT32 OV5645_MIPI_YUV_SensorInit(struct SENSOR_FUNCTION_STRUCT **pfFunc)
{
	/* To Do : Check Sensor status here */
	if (pfFunc != NULL)
		*pfFunc = &SensorFuncOV5645MIPI;
	return ERROR_NONE;
}	/* SensorInit() */

